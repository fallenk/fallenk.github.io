<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS之LighterviewController | Fallenk&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="被误解的 MVC 和被神化的 MVVM被误解的 MVCMVC，全称是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。">
<meta name="keywords" content="coding">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS之LighterviewController">
<meta property="og:url" content="https://fallenk.github.io/2019/05/07/iOS之LighterviewController/index.html">
<meta property="og:site_name" content="Fallenk&#39;s Blog">
<meta property="og:description" content="被误解的 MVC 和被神化的 MVVM被误解的 MVCMVC，全称是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-07T17:03:45.969Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS之LighterviewController">
<meta name="twitter:description" content="被误解的 MVC 和被神化的 MVVM被误解的 MVCMVC，全称是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。">
  
    <link rel="alternate" href="/atom.xml" title="Fallenk&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fallenk.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Fallenk&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">经历，心得，笔记，目标</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-iOS之LighterviewController" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/07/iOS之LighterviewController/" class="article-date">
  <time datetime="2019-05-07T15:09:00.000Z" itemprop="datePublished">2019-05-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS编程/">iOS编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS之LighterviewController
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="被误解的-MVC-和被神化的-MVVM"><a href="#被误解的-MVC-和被神化的-MVVM" class="headerlink" title="被误解的 MVC 和被神化的 MVVM"></a>被误解的 MVC 和被神化的 MVVM</h1><h1 id="被误解的-MVC"><a href="#被误解的-MVC" class="headerlink" title="被误解的 MVC"></a>被误解的 MVC</h1><p>MVC，全称是 Model View Controller，是模型 (model)－视图 (view)－控制器 (controller) 的缩写。它表示的是一种常见的客户端软件开发框架。</p>
<a id="more"></a>
<h2 id="Controller-的臃肿问题何解？"><a href="#Controller-的臃肿问题何解？" class="headerlink" title="Controller 的臃肿问题何解？"></a>Controller 的臃肿问题何解？</h2><ul>
<li>「什么样的内容才应该放到 Controller 中？」</li>
<li>我们来看看 MVC 这种架构的特点。其实设计模式很多时候是为了 Don’t repeat yourself 原则来做的，<strong>该原则要求能够复用的代码要尽量复用，来保证重用。</strong>在 MVC 这种设计模式中，我们发现 View 和 Model 都是符合这种原则的。</li>
</ul>
<p>对于 View 来说，你如果抽象得好，那么一个 App 的动画效果可以很方便地移植到别的 App 上，而 Github 上也有很多 UI 控件，这些控件都是在 View 层做了很好的封装设计，使得它能够方便地开源给大家复用。</p>
<p>对于 Model 来说，它其实是用来存储业务的数据的，如果做得好，它也可以方便地复用。比如我当时在做有道云笔记 iPad 版的时候，我们就直接和 iOS 版复用了所有的 Model 层的代码。在创业做猿题库客户端时，iOS 和 iPad 版的 Model 层代码再次被复用上了。当然，因为和业务本身的数据意义相关，Model 层的复用大多数是在一个产品内部，不太可能像 View 层那样开源给社区。</p>
<p>说完 View 和 Model 了，那我们想想 Controller，Controller 有多少可以复用的？我们写完了一个 Controller 之后，可以很方便地复用它吗？结论是：非常难复用。在某些场景下，我们可能可以用 addSubViewController 之类的方式复用 Controller，但它的复用场景还是非常非常少的。</p>
<p>如果我们能够意识到 Controller 里面的代码不便于复用，我们就能知道什么代码应该写在 Controller 里面了，那就是那些不能复用的代码。在我看来，<strong>Controller 里面就只应该存放这些不能复用的代码</strong>，这些代码包括：</p>
<ul>
<li>在初始化时，构造相应的 View 和 Model。</li>
<li>监听 Model 层的事件，将 Model 层的数据传递到 View 层。</li>
<li>监听 View 层的事件，并且将 View 层的事件转发到 Model 层。<br>如果 Controller 只有以上的这些代码，那么它的逻辑将非常简单，而且也会非常短。</li>
</ul>
<h3 id="如何对-ViewController-瘦身？"><a href="#如何对-ViewController-瘦身？" class="headerlink" title="如何对 ViewController 瘦身？"></a>如何对 ViewController 瘦身？</h3><p>objc.io 是一个非常有名的 iOS 开发博客，它上面的第一课 《Lighter View Controllers》 上就讲了很多这样的技巧，我们先总结一下它里面的观点：</p>
<ul>
<li>将 UITableView 的 Data Source 分离到另外一个类中。</li>
<li>将数据获取和转换的逻辑分别到另外一个类中。</li>
<li>将拼装控件的逻辑，分离到另外一个类中。</li>
</ul>
<p>其实 MVC 虽然只有三层，但是它并没有限制你只能有三层。所以，我们可以将 Controller 里面过于臃肿的逻辑抽取出来，形成新的可复用模块或架构层次。</p>
<h3 id="将网络请求抽象到单独的类中"><a href="#将网络请求抽象到单独的类中" class="headerlink" title="将网络请求抽象到单独的类中"></a>将网络请求抽象到单独的类中</h3><p>新手写代码，直接就在 Controller 里面用 AFNetworking 发一个请求，请求的完数据直接就传递给 View。入门一些的同学，知道把这些请求代码移到另外一个静态类里面。但是我觉得还不够，所以我建议将<strong>每一个网络请求直接封装成类</strong>。</p>
<p>把每一个网络请求封装成对象其实是使用了设计模式中的 Command 模式，它有以下好处：</p>
<ul>
<li>将网络请求与具体的第三方库依赖隔离，方便以后更换底层的网络库。实际上我们公司的 iOS 客户端最初是基于 ASIHttpRequest 的，我们只花了两天，就很轻松地切换到了 AFNetworking。</li>
<li>方便在<strong>基类中处理公共逻辑</strong>，例如猿题库的数据版本号信息就统一在基类中处理。</li>
<li>方便在基类中处理缓存逻辑，以及其它一些公共逻辑。</li>
<li>方便做对象的持久化。</li>
</ul>
<p>大家如果感兴趣，可以看我们公司开源的 iOS 网络库：YTKNetwork。它在这种思考的指导下，不但将 Controller 中的代码瘦身，而且进一步演化和加强，现在它<strong>还支持诸如复杂网络请求管理，断点续传，插件机制，JSON 合法</strong>性检查等功能。<br>这部分代码从 Controller 中剥离出来后，不但简化了 Controller 中的逻辑，也达到了网络层的代码复用的效果。</p>
<h3 id="将界面的拼装抽象到专门的类中"><a href="#将界面的拼装抽象到专门的类中" class="headerlink" title="将界面的拼装抽象到专门的类中"></a>将界面的拼装抽象到专门的类中</h3><p>新手写代码，喜欢在 Controller 中把一个个 UILabel ，UIButton，UITextField 往 self.view 上用 addSubView 方法放。我建议大家可以用两种办法把这些代码从 Controller 中剥离。</p>
<p>方法一：构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。</p>
<p>方法二：用一个静态的 Util 类，帮助你做 UIView 的拼装工作。这种方式稍微做得不太彻底，但是比较简单。</p>
<p>对于一些能复用的 UI 控件，我建议用方法一。如果项目工程比较复杂，我也建议用方法一。如果项目太紧，另外相关项目的代码量也不多，可以尝试方法二。</p>
<h3 id="构造-ViewModel"><a href="#构造-ViewModel" class="headerlink" title="构造 ViewModel"></a>构造 ViewModel</h3><p>谁说 MVC 就不能用 ViewModel 的？MVVM 的优点我们一样可以借鉴。<strong>具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程</strong>。</p>
<p>这样抽象之后，View 只接受 ViewModel，而 Controller 只需要传递 ViewModel 这么一行代码。而另外<strong>构造 ViewModel 的过程，我们就可以移动到另外的类中了</strong>。</p>
<p>在具体实践中，我建议大家专门<strong>创建构造 ViewModel 工厂类</strong>，参见 工厂模式。另外，也可以专门将数据存取都抽将到一个 Service 层，由这<strong>层来提供 ViewModel 的获取</strong>。</p>
<h3 id="专门构造存储类"><a href="#专门构造存储类" class="headerlink" title="专门构造存储类"></a>专门构造存储类</h3><p>刚刚说到 ViewModel 的构造可以抽奖到一个 Service 层。与此相应的，数据的存储也应该由专门的对象来做。在小猿搜题项目中，我们由一个叫 UserAgent 的类，专门来处理本地数据的存取。</p>
<p>数据存取放在专门的类中，就可以针对存取做额外的事情了。比如：</p>
<ul>
<li>对一些热点数据增加缓存</li>
<li>处理数据迁移相关的逻辑<br>如果要做得更细，可以把存储引擎再抽象出一层。这样你就可以方便地切换存储的底层，例如从 sqlite 切换到 key-value 的存储引擎等。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过代码的抽取，我们可以将原本的 MVC 设计模式中的 ViewController 进一步拆分，构造出 <strong>网络请求层</strong>、<strong>ViewModel 层</strong>、<strong>Service 层</strong>、<strong>Storage 层</strong>等其它类，来配合 Controller 工作，从而使 Controller 更加简单，我们的 App 更容易维护。</p>
<h2 id="被神化的-MVVM"><a href="#被神化的-MVVM" class="headerlink" title="被神化的 MVVM"></a>被神化的 MVVM</h2><p>MVVM 是 Model-View-ViewModel 的简写。</p>
<p>MVVM 在使用当中，通常还会利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。所以，MVVM 模式有些时候又被称作：model-view-binder 模式。<br>具体在 iOS 中，可以使用 KVO 或 Notification 技术达到这种效果。</p>
<p>第一点：<strong>数据绑定使得 Bug 很难被调试</strong>。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。</p>
<p>第二点：对于过大的项目，<strong>数据绑定需要花费更多的内存</strong>。</p>
<p>某种意义上来说，我认为就是数据绑定使得 MVVM 变得复杂和难用了。但是，这个缺点同时也被很多人认为是优点。</p>
<h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><p>函数式编程（Functional Programming）和响应式编程（React Programming）也是当前很火的两个概念，它们的结合可以很方便地实现数据的绑定。</p>
<ul>
<li>函数式编程（Functional Programming），函数也变成一等公民了，可以拥有和对象同样的功能，例如当成参数传递，当作返回值等。看看 Swift 语言带来的众多函数式编程的特性，就你知道这多 Cool 了。</li>
<li>响应式编程（React Programming），原来我们基于事件（Event）的处理方式都弱了，现在是基于输入（在 ReactiveCocoa 里叫 Signal）的处理方式。输入还可以通过函数式编程进行各种 Combine 或 Filter，尽显各种灵活的处理。</li>
<li>无状态（Stateless），状态是函数的魔鬼，无状态使得函数能更好地测试。</li>
<li>不可修改（Immutable），数据都是不可修改的，使得软件逻辑简单，也可以更好地测试。</li>
</ul>
<p>而我想说，我们需要保持的是一个拥抱变化的心，以及理性分析的态度。在新技术的面前，不盲从，也不守旧，一切的决策都应该建立在认真分析的基础上，这样才能应对技术的变化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fallenk.github.io/2019/05/07/iOS之LighterviewController/" data-id="cjzqqm9oq002jy88ol7o7azg1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/coding/">coding</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/05/08/iOS路由设计/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          iOS路由设计
        
      </div>
    </a>
  
  
    <a href="/2019/05/07/iOS学习入门/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">iOS学习入门</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#被误解的-MVC-和被神化的-MVVM"><span class="toc-number">1.</span> <span class="toc-text">被误解的 MVC 和被神化的 MVVM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#被误解的-MVC"><span class="toc-number">2.</span> <span class="toc-text">被误解的 MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller-的臃肿问题何解？"><span class="toc-number">2.1.</span> <span class="toc-text">Controller 的臃肿问题何解？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何对-ViewController-瘦身？"><span class="toc-number">2.1.1.</span> <span class="toc-text">如何对 ViewController 瘦身？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将网络请求抽象到单独的类中"><span class="toc-number">2.1.2.</span> <span class="toc-text">将网络请求抽象到单独的类中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将界面的拼装抽象到专门的类中"><span class="toc-number">2.1.3.</span> <span class="toc-text">将界面的拼装抽象到专门的类中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造-ViewModel"><span class="toc-number">2.1.4.</span> <span class="toc-text">构造 ViewModel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#专门构造存储类"><span class="toc-number">2.1.5.</span> <span class="toc-text">专门构造存储类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">2.2.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#被神化的-MVVM"><span class="toc-number">2.3.</span> <span class="toc-text">被神化的 MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReactiveCocoa"><span class="toc-number">2.4.</span> <span class="toc-text">ReactiveCocoa</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 Fallenk Liu&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;fallenk_liu@yeah.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>