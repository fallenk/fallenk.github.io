<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>三维动画与交互技术复习4 | Fallenk&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="复习4片段着色器 处理纹理、颜色求和、雾 “纹理”最重要，根据纹理和纹理坐标对每个像素的颜色进行计算   顶点-片段 着色器 顶点为片段着色器提供数据 像素颜色(根据光照计算)，包括主要颜色和辅助颜色 纹理坐标，根据变换矩阵对纹理坐标进行变换 雾因子">
<meta name="keywords" content="考试">
<meta property="og:type" content="article">
<meta property="og:title" content="三维动画与交互技术复习4">
<meta property="og:url" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/index.html">
<meta property="og:site_name" content="Fallenk&#39;s Blog">
<meta property="og:description" content="复习4片段着色器 处理纹理、颜色求和、雾 “纹理”最重要，根据纹理和纹理坐标对每个像素的颜色进行计算   顶点-片段 着色器 顶点为片段着色器提供数据 像素颜色(根据光照计算)，包括主要颜色和辅助颜色 纹理坐标，根据变换矩阵对纹理坐标进行变换 雾因子">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo1.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo2.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo3.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo4.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo5.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo6.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo7.png">
<meta property="og:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo8.png">
<meta property="og:updated_time" content="2019-01-12T16:14:33.600Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="三维动画与交互技术复习4">
<meta name="twitter:description" content="复习4片段着色器 处理纹理、颜色求和、雾 “纹理”最重要，根据纹理和纹理坐标对每个像素的颜色进行计算   顶点-片段 着色器 顶点为片段着色器提供数据 像素颜色(根据光照计算)，包括主要颜色和辅助颜色 纹理坐标，根据变换矩阵对纹理坐标进行变换 雾因子">
<meta name="twitter:image" content="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/demo1.png">
  
    <link rel="alternate" href="/atom.xml" title="Fallenk&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fallenk.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Fallenk&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">经历，心得，笔记，目标</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-三维动画与交互技术复习4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/三维动画与交互技术复习4/" class="article-date">
  <time datetime="2019-01-08T19:19:56.000Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/游戏开发/">游戏开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      三维动画与交互技术复习4
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="复习4"><a href="#复习4" class="headerlink" title="复习4"></a>复习4</h1><h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><ul>
<li>处理纹理、颜色求和、雾<ul>
<li>“纹理”最重要，根据纹理和纹理坐标对每个像素的颜色进行计算</li>
</ul>
</li>
<li>顶点-片段 着色器<ul>
<li>顶点为片段着色器提供数据<ul>
<li>像素颜色(根据光照计算)，包括主要颜色和辅助颜色</li>
<li>纹理坐标，根据变换矩阵对纹理坐标进行变换</li>
<li>雾因子</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="使用片段处理颜色"><a href="#使用片段处理颜色" class="headerlink" title="使用片段处理颜色"></a>使用片段处理颜色</h3><p><img src="/2019/01/09/三维动画与交互技术复习4/demo1.png" alt=""></p>
<h3 id="基于片段着色器的光照"><a href="#基于片段着色器的光照" class="headerlink" title="基于片段着色器的光照"></a>基于片段着色器的光照</h3><p><img src="/2019/01/09/三维动画与交互技术复习4/demo2.png" alt=""></p>
<h3 id="过程纹理"><a href="#过程纹理" class="headerlink" title="过程纹理"></a>过程纹理</h3><p><img src="/2019/01/09/三维动画与交互技术复习4/demo3.png" alt=""></p>
<h3 id="纹理映射回顾"><a href="#纹理映射回顾" class="headerlink" title="纹理映射回顾"></a>纹理映射回顾</h3><p><img src="/2019/01/09/三维动画与交互技术复习4/demo4.png" alt=""></p>
<h3 id="纹理坐标生成"><a href="#纹理坐标生成" class="headerlink" title="纹理坐标生成"></a>纹理坐标生成</h3><p><img src="/2019/01/09/三维动画与交互技术复习4/demo5.png" alt=""></p>
<h3 id="纹理生成的方法"><a href="#纹理生成的方法" class="headerlink" title="纹理生成的方法"></a>纹理生成的方法</h3><ol>
<li>物体线性：<br><img src="/2019/01/09/三维动画与交互技术复习4/demo6.png" alt=""><br>旋转物体，纹理固定</li>
<li>视觉线性：随物体旋转变化</li>
<li>球形贴图：对环境反射</li>
</ol>
<h3 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h3><ul>
<li>6个纹理组成立方体6个面</li>
</ul>
<h3 id="高度图与凹凸纹理"><a href="#高度图与凹凸纹理" class="headerlink" title="高度图与凹凸纹理"></a>高度图与凹凸纹理</h3><ul>
<li>使用高度图的像素值确定物体表面的光照特性</li>
<li>凹凸纹理分：<ol>
<li>位移纹理<br><img src="/2019/01/09/三维动画与交互技术复习4/demo7.png" alt=""></li>
<li>法线纹理<br><img src="/2019/01/09/三维动画与交互技术复习4/demo8.png" alt=""></li>
</ol>
</li>
</ul>
<h1 id="总结复习"><a href="#总结复习" class="headerlink" title="总结复习"></a>总结复习</h1><h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><ol>
<li>增强现实技术AR<ul>
<li>融合了三维动画、立体视觉和图像处理</li>
<li>建模、渲染、位置标定、图像融合</li>
</ul>
</li>
<li>OpenGL是一个创建实时3D图像的编程接口</li>
<li>三维表示：宽，高，深<br> 2D+透视 = 3D</li>
<li>真正的3D是通过两只眼睛观察同一个物体产生视差的两个图像，在人脑产生3D的视觉感受</li>
<li>渲染： 将数学和图形数据转换成3D空间图像的操作</li>
<li>投影：将3D坐标转换成二维坐标</li>
<li>光栅化：使用像素进行图形填充</li>
<li>纹理贴图：纹理是一幅贴到三角形或多边形上的图片</li>
<li>视口映射：<ul>
<li>把<strong>绘图坐标</strong>映射到<strong>窗口坐标</strong></li>
</ul>
</li>
</ol>
<h1 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h1><ol>
<li>物质有原子组成，3D图形有图元组成</li>
<li>点：每个顶点在屏幕上都是一个单独的点</li>
<li>线：。。。</li>
<li>矩阵：三维空间的反射变化都是通过矩阵运算的：旋转、平移、缩放</li>
<li>几个基本概念：<ul>
<li>视图变化：设定观察者或摄像机位置</li>
<li>模型变换：在场景中移动物体</li>
<li>模型视图：模型与视图保持一致</li>
<li>投影变换：设定视景体的大小和形状</li>
<li>视口变换：窗口缩放</li>
</ul>
</li>
<li>视图变化：<ol>
<li>视图变换：设置视点位置和视线</li>
<li>默认从(0,0,0)看向z轴负方向</li>
</ol>
</li>
<li>模型变换<ol>
<li>模型变化 操作模型和特定对象</li>
</ol>
</li>
<li>投影变换：定义了 视景体 创建了裁剪平面</li>
<li>视口变换：从颜色缓冲区到窗口像素之前的映射；缩放，比例</li>
<li>模型视图矩阵</li>
</ol>
<h1 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h1><ol>
<li>光照模型就是计算几何物体表面上任一点的<strong>光亮度和色彩</strong>组成的数学计算公式<ul>
<li>局部：仅与被照明物体和光源有关</li>
<li>全局：与场景任一点有关</li>
</ul>
</li>
<li>局部：光是点光源，非透明物体，只考虑 反射光：环境光，漫反射光、镜面反射光</li>
</ol>
<h1 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h1><ol>
<li>雾：深度暗示</li>
<li>积累缓冲区<ul>
<li>原理：</li>
<li><ol>
<li>OpenGL在渲染到颜色缓冲区，不直接显示在窗口上，而好似复制到积累缓冲区</li>
</ol>
</li>
<li><ol start="2">
<li>反复混合后，再执行缓冲去交换显示</li>
</ol>
</li>
<li>作用：</li>
<li><ol>
<li>是不同视点多次渲染场景，抗锯齿，由于多重采样</li>
</ol>
</li>
<li><ol start="2">
<li>运动模糊</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h1><ol>
<li>渲染：计算机根据<strong>模型</strong>创建<strong>图像</strong><ul>
<li>模型有几何图元构成，</li>
<li>最终渲染的图像由屏幕像素构成</li>
</ul>
</li>
<li>渲染过程：<ol>
<li>建模： 使用几何图元建立模型，得数学描述</li>
<li>变换：三维空间；排列物体，从而得到场景有利位置</li>
<li>着色：计算机物体颜色</li>
<li>光栅化：将物体数学描述和相关信息转为屏幕信息</li>
</ol>
</li>
<li>什么是渲染管线？<ul>
<li>当我们把绘制的图形传递给OpenGL后，OpenGL还要做许多才能完成3D空间到屏幕的投影。这一系列的过程称为OpenGL的渲染管线。</li>
<li>一般的渲染步骤如下：<ol>
<li>显示列表；</li>
<li>求值程序；</li>
<li>顶点操作；</li>
<li>图元装配；</li>
<li>像素操作；</li>
<li>纹理装配；</li>
<li>光栅化；</li>
<li>片段操作；</li>
</ol>
</li>
</ul>
</li>
<li>OpenGL中的渲染管线主要分为两个阶段：<ul>
<li>首先是<strong>基于顶点</strong>的操作，然后图元被光栅化，产生片段；</li>
<li>在片段写入到帧缓冲之前进行纹理、雾和其他<strong>基于片段的操作</strong>；</li>
</ul>
</li>
<li>顶点处理分为4个阶段：顶点变换、光照、纹理坐标和变换、裁剪</li>
</ol>
<h1 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h1><ol>
<li>什么是动画？<ol>
<li>从制作层面上讲：动画是指<strong>不使用真人表演拍摄</strong>，而是用各种技术手段产生的具有艺术价值的活动影像；</li>
<li>从技术层面上讲：动画是将<strong>一系列静态图像顺序播放</strong>，利用人的<strong>视觉滞留效应</strong>，产生连续运动的观赏效果。</li>
</ol>
</li>
</ol>
<h1 id="第八讲（考试要点复习）"><a href="#第八讲（考试要点复习）" class="headerlink" title="第八讲（考试要点复习）"></a>第八讲（考试要点复习）</h1><ol>
<li>什么是OpenGL？<ol>
<li>OpenGL = Open Graphics Library</li>
<li>定义：图形硬件的一种软件接口</li>
<li>最初由SGI创建，用于在不同硬件体系结构的图形设备上进行二维和三维图形的绘制；</li>
<li>OpenGL不是编程语言，但是包含了GLSL，其特点是并行浮点矢量运算速度极快，但不能进行流程控制。</li>
</ol>
</li>
<li>OpenGL的扩展机制：<ul>
<li>ARB：标准扩展；</li>
<li>EXT：多家支持的扩展；</li>
</ul>
</li>
<li>OpenGL与平台<ol>
<li>面向嵌入式平台的OpenGL ES；</li>
<li>面向浏览器的WebGL；</li>
<li>面向MS Windows的wgl；</li>
<li>面向mac os的cgl；</li>
<li>面向X Windows的glx;</li>
</ol>
</li>
<li>OpenGL与相关工具<ol>
<li>跨平台工具箱：GLUT = OpenGL Utility Toolkit</li>
<li>glut由SGI开发；能够兼容win/linux/mac;最新开源的freeglut;</li>
<li>处理扩展的包装库：GLEW</li>
</ol>
</li>
<li>OpenGL状态机<ol>
<li>OpenGL使用<strong>一组状态变量</strong>的集合来保持图形渲染管线的状态；</li>
<li>OpenGL使用了一种<strong>状态模型（状态机）来跟踪所有状态变量</strong>；</li>
<li>当一个值被设置后，就一直保持这个状态；</li>
</ol>
</li>
<li>基本几何图元<ol>
<li>GL_POINTS:每个顶点在屏幕上都是一个单独的点；</li>
<li>GL_LINES:每一对顶点定义一个线段；</li>
<li>GL_LINE_STRIP:从第一个顶点依次经过后续顶点而绘制的线条；</li>
<li>GL_LINE_LOOP:同上，但最后一个顶点和第一个顶点连接；</li>
<li>GL_TRIANGLES:每三个顶点定义一个新的三角形；</li>
<li>GL_TRIANGLE_STRIP:公用一个条带上的顶点的一组三角形；</li>
<li>GL_TRIANGLE_FAN:以一个原点为中心呈扇形排列，共用相邻顶点的一组三角形；</li>
</ol>
</li>
<li>三角形的环绕属性：逆时针为正方向，可以通过glFrontFace（GL_CW）修改。</li>
<li>背面的剔除<ol>
<li>画家算法 1. 将需要绘制的图元排序，首先绘制最远的，依次靠近；2.低效和资源占用；</li>
<li>隐面剔除 – glEnable(GL_CULL_FACE)； – glDisable(GL_CULL_FACE)</li>
</ol>
</li>
<li>深度测试的对比：自遮挡的对象，没有启用深度测试就会产生显示错误。</li>
<li>多边形偏移：当图元的坐标非常接近，即使启用深度测试，也会产生闪烁，Z值相同的情况。</li>
<li>什么是向量？三维向量用一个三元组(X,Y,Z)表示。<ol>
<li>顶点是一个向量，表示空间中的一个位置；</li>
<li>三维坐标可以表示一个向量，向量有长度，向量也有方向，所以，向量=向+量。</li>
</ol>
</li>
<li>向量的定义<ol>
<li>向量是从坐标系原点到点(X,Y,Z)的带箭头的线段；</li>
<li>空间中的一个点，既是顶点，又是向量；</li>
</ol>
</li>
<li>向量在图形中的作用<ol>
<li>表示位置：顶点；</li>
<li>表示方向：视线方向，平面法线；</li>
</ol>
</li>
<li>单位向量<ol>
<li>长度为1的向量称为单位向量；</li>
<li>将一个任意向量转化为单位向量，称为归一化，将该向量除以向量的长度。</li>
</ol>
</li>
<li>点乘<ol>
<li>两个三维向量的点乘是一个标量；</li>
<li>表示一个向量投影到另外一个向量的长度；</li>
<li>在单位向量中，两个向量的点乘是其夹角的余弦值；</li>
</ol>
</li>
<li>叉乘<ol>
<li>两个向量的叉乘得到的是垂直于这两个向量的第三个向量；</li>
<li>用途：计算平面的法向；</li>
<li>特点：顺序不可交换；</li>
</ol>
</li>
<li>矩阵<ol>
<li>矩阵是一个由行和列构成的数据结构；</li>
<li>在程序中一般以二维数组存放；</li>
<li>OpenGL是以列主存放的；</li>
<li>矩阵的作用：空间变换</li>
<li>三维空间中的仿射变换都是使用矩阵运算进行的：旋转、平移、缩放；</li>
<li>OpenGL中的矩阵：视图变换、模型变换、投影变换；</li>
</ol>
</li>
<li>概念理解：<ol>
<li>视图变换:设定观察者或摄像机的位置；</li>
<li>模型变换：在场景中移动物体；</li>
<li>模型视图：模型和视图的一致性；</li>
<li>投影变换：设定视景体的大小和形状；</li>
<li>视口变换：窗口缩放；</li>
</ol>
</li>
<li>视图变换<ol>
<li>视图变换的作用就是设定观察者的位置，以及视线方向；</li>
<li>可以理解为在场景中摆放摄像机：</li>
<li>在任何其他变换之前先用<strong>视图变换</strong>，能够保证与视觉坐标系一致；</li>
<li>默认从(0,0,0)看向Z轴负方向；</li>
<li>正投影中，视点在Z轴正无穷远处，可以看到视景体中的任何物体；</li>
</ol>
</li>
<li>模型变换<ul>
<li>模型变换用于操作模型和其中的特定对象；</li>
<li>将对象移动到需要的位置，然后进行旋转和缩放；</li>
</ul>
</li>
<li>模型和视图的一致性：模型变换和视图变换最后形成一个统一的模型视图矩阵。</li>
<li>模型视图矩阵<ul>
<li>模型视图矩阵是一个4*4矩阵；</li>
<li>原始顶点坐标是一个四维向量，与模型视图矩阵相乘，得到变换后的新坐标；</li>
<li>注意：在数学上向量应该放在右边，左乘一个变换矩阵；</li>
<li>在OpenGL中，向量是行向量，矩阵是列主矩阵，相当于整体转置了；</li>
</ul>
</li>
<li>什么是投影？ 从三维裁剪空间到二维屏幕空间。</li>
<li>投影的方式及其特点？<ul>
<li>正投影: 没有畸变，视觉不真实；视景体为方形</li>
<li>透视投影:视景体为平截头体；</li>
</ul>
</li>
<li>OpenGL通过分别指定红、绿、蓝成分的强度来指定一种颜色。</li>
<li>对所有可用的颜色进行建模，创建立方体，称为RGB颜色空间。<ul>
<li>原点(0,0,0)，黑色；</li>
<li>对角线顶点(255,255,255),白色；</li>
<li>从原点到每根轴的方向，分别是红绿蓝的饱和分布。</li>
</ul>
</li>
<li>光照模型<ol>
<li>局部光照模型：光强仅与被照明的物体和光源有关；</li>
<li>全局光照模型：光强与场景中任一点都相关；</li>
</ol>
</li>
<li>局部光照模型：假定光是点光源，物体是非透明物体，且表面光滑，透射光和散射光将近似于零<ul>
<li>局部光照模型中只考虑反射光的作用；</li>
<li>反射光包括环境光、漫反射光、镜面反射光；</li>
</ul>
</li>
<li>环境光<ol>
<li>环境光并不来自任何特定的方向，他来自某个光源，但是光线在场景中四处反射。</li>
<li>环境光将物体的各个方向的表面均匀照亮。</li>
<li>颜色与旋转和观察角无关。</li>
<li>照射在物体上的光来自各个方向，又均匀向各个方向反射。</li>
</ol>
</li>
<li>散射光<ol>
<li>OpenGL的散射光具有方向性，来自一个特定的方</li>
<li>根据入射光线的角度在表面均匀地反射。</li>
<li>在点光源的照射下，物体表面的不同部分亮度不同，亮度的大小依赖于物体表面的朝向以及它与点光源之间的距离。</li>
<li>漫反射特点：光源来自一个方向，反射光均匀地射向各个方向。</li>
</ol>
</li>
<li>镜面光<ol>
<li>镜面光具有很强的方向性；</li>
<li>照射表面形成亮点；</li>
</ol>
</li>
<li>镜面反射<ol>
<li>反射方向是几乎一致的；</li>
<li>镜面反射可以使物体看起来闪闪发光；</li>
<li>不同的角度，镜面反射的效果是不一样的；</li>
</ol>
</li>
<li>表面法线：法线的方向决定了多边形正面的朝向。</li>
<li>局部光照模型的局限：<ul>
<li>仅考虑从光源直接发出的光线对物体表面光亮度的贡献；</li>
<li>没有考虑光线在物体之间的相互反射和透射。</li>
</ul>
</li>
<li>全局光照模型：Whitted模型； 可模拟现实世界中景物表面之间的镜面反射和透射现象的贡献。</li>
<li>Whitted模型: 假设从某一观察方向V所观察到的物体表面某点P的光亮度的贡献来自三个方面：<ol>
<li>由光源直接照射引起的反射光亮度；</li>
<li>环境镜面反射光；</li>
<li>环境规则透射光；</li>
</ol>
</li>
<li>为什么会走样？ 连续几何空间和离散屏幕像素之间的矛盾。</li>
<li>多重采样: 反锯齿功能的局限性：在复杂场景中，需要对所有图元进行前后排序。</li>
<li>几个术语：全屏反锯齿；超级采样抗锯齿；多重采样抗锯齿；</li>
<li>积累缓冲区<ul>
<li>原理：</li>
<li><ol>
<li>OpenGL在渲染到颜色缓冲区之后，不是直接显示在窗口上，而是复制到积累缓冲区；</li>
</ol>
</li>
<li><ol start="2">
<li>在积累缓冲区反复混合后，再执行缓冲区交换进行显示；</li>
</ol>
</li>
<li>作用：</li>
<li><ol>
<li>使用不同的视点多次渲染场景，积累后可以达到整个场景的完全抗锯齿，效果优于多重采样；</li>
</ol>
</li>
<li><ol start="2">
<li>实现运动模糊效果；</li>
</ol>
</li>
</ul>
</li>
<li>位图和像素图<ol>
<li>位图用2色（1位）表示一个点；</li>
<li>像素图用256色（8位）表示一个点；</li>
</ol>
</li>
<li>纹理贴图基本概念<ol>
<li>纹理贴图就是把图像数据应用到三维图元中；</li>
<li>纹理贴图给三维图形带来了丰富的表面特征；</li>
<li>纹理单元是纹理中的个体图像元素；</li>
</ol>
</li>
<li>最临近过滤<ol>
<li>最临近过滤：会出现马赛克；</li>
<li>线性过滤：平滑更接近真实；</li>
</ol>
</li>
<li>为什么使用mipmapping?<ol>
<li>解决闪烁的问题；</li>
<li>减少纹理加载的浪费；</li>
<li>mipmapping纹理由一系列纹理图像组成，每个图形的大小都是前面的一半大小。Mipmapping是一种LOD技术。</li>
</ol>
</li>
<li>纹理对象<ol>
<li>纹理对象可以使我们一次加载多个图像，并且在这些纹理对象之间切换；</li>
<li>纹理对象是一个<strong>无符号整数</strong>；</li>
</ol>
</li>
<li>各向异性过滤<ol>
<li>对周围各个方向上的<strong>像素进行取样计算后映射到目标像素</strong>上的技术；</li>
<li>与双线性过滤和三线性过滤相比，它在大角度显示方面具有更高的精度，令画面更逼真，但计算量也更大，对显卡的要求更高。</li>
</ol>
</li>
<li>OpenGL渲染管线，什么是渲染管线？<ol>
<li>当我们把绘制的图形传递给OpenGL后，OpenGL还要做许多步骤才能完成3D空间到屏幕的投影，这一系列的过程称为OpenGL渲染流水线。</li>
<li>一般的渲染流水线有如下几步：<ol>
<li>显示列表；</li>
<li>求值程序；</li>
<li>顶点操作；</li>
<li>图元装配；</li>
<li>像素操作；</li>
<li>纹理装配；</li>
<li>光栅化；</li>
<li>片段操作；</li>
</ol>
</li>
</ol>
</li>
<li>OpenGL中的固定管线总结：OpenGL中的渲染管线主要分为两个阶段：<ol>
<li>首先是基于顶点的操作，然后图元被光栅化，产生片段；</li>
<li>在片段写入到帧缓冲区之前进行<strong>纹理、雾以及其他基于片段</strong>的操作；</li>
</ol>
</li>
<li>固定的顶点处理：<ol>
<li>基于顶点的阶段<strong>从一组顶点属性开始</strong>；</li>
<li>这些属性包括<strong>对象空间位置，法线，主颜色和辅助颜色以及纹理坐标</strong>；</li>
<li>基于顶点的处理的结果是<strong>裁剪空间位置</strong>、正面和背面主颜色和辅助颜色、一个雾坐标、纹理坐标、点大小；</li>
<li>顶点处理分为4个阶段：<strong>顶点变换、光照、纹理坐标变换、裁剪</strong>；</li>
</ol>
</li>
<li>固定的片段操作<ol>
<li>用一个片段以及与它相关的数据作为输入，包括<strong>纹理坐标、主颜色和辅助颜色、雾坐标</strong>；</li>
<li>基于<strong>片段操作</strong>的结果是一个<strong>颜色值</strong>；</li>
<li>基于片段的固定功能管线分为4个阶段：<ol>
<li>纹理应用和环境；</li>
<li>颜色求和；</li>
<li>雾应用；</li>
<li>抗锯齿应用；</li>
</ol>
</li>
</ol>
</li>
<li>可编程渲染管线<ul>
<li>使用着色器替代固定管线中的部分阶段；</li>
<li>着色器也可以称为程序；</li>
<li>着色器实质是应用程序所定义的自定义程序，用于接替固定功能管线阶段的职责；</li>
</ul>
</li>
<li>OpenGL着色语言<ul>
<li>OpenGL着色语言（GLSL）是一种对GPU进行编程的高级语言，具有紧凑的代码，良好的可读性和更高的效率；GLSL语法和C语言的非常接近；</li>
</ul>
</li>
<li>着色器对象<ul>
<li>GLSL使用两种类型的对象：着色器对象和程序对象；</li>
<li><strong>着色器对象加载着色器文本</strong>并对它进行编译；</li>
<li>着色器对象是最小的作用单元，但是不能独立运行，需要绑定到“程序”中执行。</li>
</ul>
</li>
<li>着色器统一值<ul>
<li>属性是每个<strong>顶点位置、表面法向和纹理坐标</strong>等都需要的，而统一值则用于整个图元批次想保持不变的着色器传递数据；</li>
<li>对于顶点着色器，统一值可能是变换矩阵；</li>
<li>统一值是只读的；</li>
</ul>
</li>
<li>高度图和凹凸纹理<ul>
<li>使用高度图的像素值确定物体表面的光照特性；</li>
<li>凹凸纹理分为：位移映射和法线映射；</li>
<li>位移映射：位移贴图是使用高度图将经过纹理化的表面上实际几何点位置<strong>沿着表面法线根据保存在纹理中的数值进行移位</strong>的技术。</li>
</ul>
</li>
<li>顶点数组：使用<strong>顶点数组可以加速数据载入</strong>，在多次绘制间保存和共享数据。</li>
<li>索引顶点数组：索引顶点数组<strong>不是按顺序从头遍历顶点数组，由一个单独的索引数组</strong>指定。<ul>
<li>优点：两个三角形带之间共享顶点，节省内存，减少变换开销；</li>
</ul>
</li>
<li>动画的分类：<ol>
<li>按照制作方式分类：<ol>
<li>传统动画：手绘动画；</li>
<li>定格动画：粘土动画、木偶动画；</li>
<li>计算机动画：二维动画、三维动画；</li>
</ol>
</li>
</ol>
</li>
<li>三维动画的种类<ol>
<li>变形动画；</li>
<li>骨骼动画；</li>
</ol>
</li>
<li>变形动画的优点：<ol>
<li>能够精细的控制形状的变化；</li>
<li>针对面部表情动画特别适用；</li>
<li>变形动画的缺点：</li>
<li>动画数据量大；制作复杂度高；很难在多个角色间重用；</li>
</ol>
</li>
<li>骨骼动画技术：<ol>
<li>模型创建；</li>
<li>骨骼创建；</li>
<li>骨骼绑定；</li>
<li>动画设定：关键帧、动作数据</li>
</ol>
</li>
<li>朝向的表示：<ol>
<li>使用矩阵表示；</li>
<li>使用欧拉角；</li>
<li>使用四元数；</li>
</ol>
</li>
<li>动作捕捉的优点：真实记录了每个动作细节；<ul>
<li>缺点：</li>
<li>难以修改：对动作数据的修改很容易导致失真；</li>
<li>难以控制：没有很好的方法对捕获的动作进行控制；</li>
<li>难以重用：应用到不同的角色、骨架；</li>
</ul>
</li>
<li>OpenGL中的矩阵不是二维数组、而是一维数组；</li>
<li>关键帧动画<ol>
<li>动画师指定少量关键帧的骨骼姿势；</li>
<li>计算机通过差值算法计算中间姿势；</li>
</ol>
</li>
<li>插值技术：线性插值，非线性插值；<ul>
<li>线性插值技术：优点：实现单一、计算快速；缺点：运动单一、过渡生硬；</li>
<li>非线性插值技术：优点：过渡运动连续；</li>
</ul>
</li>
<li>朝向的表示：矩阵、欧拉角、四元数。</li>
<li>动作引擎技术主要处<strong>理动作控制和动作反馈</strong>。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fallenk.github.io/2019/01/09/三维动画与交互技术复习4/" data-id="cjve07soq002unb8o0ecbtswn" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/考试/">考试</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/01/09/智能架构/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          智能架构
        
      </div>
    </a>
  
  
    <a href="/2019/01/08/三维动画与交互技术复习3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">三维动画与交互技术复习3</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#复习4"><span class="toc-number">1.</span> <span class="toc-text">复习4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#片段着色器"><span class="toc-number">1.1.</span> <span class="toc-text">片段着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用片段处理颜色"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用片段处理颜色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于片段着色器的光照"><span class="toc-number">1.1.2.</span> <span class="toc-text">基于片段着色器的光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过程纹理"><span class="toc-number">1.1.3.</span> <span class="toc-text">过程纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理映射回顾"><span class="toc-number">1.1.4.</span> <span class="toc-text">纹理映射回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理坐标生成"><span class="toc-number">1.1.5.</span> <span class="toc-text">纹理坐标生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纹理生成的方法"><span class="toc-number">1.1.6.</span> <span class="toc-text">纹理生成的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#立方体贴图"><span class="toc-number">1.1.7.</span> <span class="toc-text">立方体贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高度图与凹凸纹理"><span class="toc-number">1.1.8.</span> <span class="toc-text">高度图与凹凸纹理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结复习"><span class="toc-number">2.</span> <span class="toc-text">总结复习</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一讲"><span class="toc-number">3.</span> <span class="toc-text">第一讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二讲"><span class="toc-number">4.</span> <span class="toc-text">第二讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三讲"><span class="toc-number">5.</span> <span class="toc-text">第三讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四讲"><span class="toc-number">6.</span> <span class="toc-text">第四讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五讲"><span class="toc-number">7.</span> <span class="toc-text">第五讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六讲"><span class="toc-number">8.</span> <span class="toc-text">第六讲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八讲（考试要点复习）"><span class="toc-number">9.</span> <span class="toc-text">第八讲（考试要点复习）</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 Fallenk Liu&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;fallenk_liu@yeah.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>