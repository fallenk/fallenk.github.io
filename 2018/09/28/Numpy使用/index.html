<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Numpy使用 | Fallenk&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Numpy教程Python中用于科学计算的核心库。numpy（Numerical Python）提供了python对多维数组对象的支持：ndarray，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。">
<meta name="keywords" content="编程,代码">
<meta property="og:type" content="article">
<meta property="og:title" content="Numpy使用">
<meta property="og:url" content="https://fallenk.github.io/2018/09/28/Numpy使用/index.html">
<meta property="og:site_name" content="Fallenk&#39;s Blog">
<meta property="og:description" content="Numpy教程Python中用于科学计算的核心库。numpy（Numerical Python）提供了python对多维数组对象的支持：ndarray，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://fallenk.github.io/2018/09/28/Numpy使用/output_58_0.png">
<meta property="og:updated_time" content="2018-09-28T12:00:05.381Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Numpy使用">
<meta name="twitter:description" content="Numpy教程Python中用于科学计算的核心库。numpy（Numerical Python）提供了python对多维数组对象的支持：ndarray，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。">
<meta name="twitter:image" content="https://fallenk.github.io/2018/09/28/Numpy使用/output_58_0.png">
  
    <link rel="alternate" href="/atom.xml" title="Fallenk&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fallenk.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Fallenk&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">经历，心得，笔记，目标</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Numpy使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/Numpy使用/" class="article-date">
  <time datetime="2018-09-28T11:52:39.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python学习/">Python学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Numpy使用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Numpy教程"><a href="#Numpy教程" class="headerlink" title="Numpy教程"></a>Numpy教程</h1><p>Python中用于科学计算的核心库。<code>numpy（Numerical Python）</code>提供了python对<strong>多维数组对象</strong>的支持：<code>ndarray</code>，具有矢量运算能力，快速、节省空间。numpy支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p>
<a id="more"></a>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><p>NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。<br>NumPy的数组类被称作 ndarray 。通常被称作数组。注意numpy.array和标准Python库类array.array并不相同，后者只处理一维数组和提供少量功能。更多重要ndarray对象属性有：</p>
<ul>
<li>ndarray.ndim<br>数组轴的个数，在python的世界中，轴的个数被称作秩</li>
<li>ndarray.shape<br>数组的维度。这是一个指示数组在每个维度上大小的整数元组。例如一个n排m列的矩阵，它的shape属性将是(n,m),这个元组的长度显然是秩，即维度或者ndim属性</li>
<li>ndarray.size<br>数组元素的总个数，等于shape属性中元组元素的乘积。</li>
<li>ndarray.dtype<br>一个用来描述数组中元素类型的对象，可以通过创造或指定dtype使用标准Python类型。另外NumPy提供它自己的数据类型。</li>
<li>ndarray.itemsize<br>数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为8(=64/8),又如，一个元素类型为complex32的数组item属性为4(=32/8).</li>
<li>ndarray.data<br>包含实际数组元素的缓冲区，通常我们不需要使用这个属性，因为我们总是通过索引来使用数组中的元素。</li>
</ul>
<h2 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line">a = arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(type(a))</span><br><span class="line">print(<span class="string">'a.ndim'</span>,a.ndim)</span><br><span class="line">print(<span class="string">'a.shape'</span>, a.shape)</span><br><span class="line">print(<span class="string">'a.size'</span>, a.size)</span><br><span class="line">print(<span class="string">'a.dtype'</span>, a.dtype)</span><br><span class="line">print(<span class="string">'a.itemsize'</span>, a.itemsize)</span><br><span class="line">print(<span class="string">'a.data'</span>,a.data)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
&lt;class &apos;numpy.ndarray&apos;&gt;
a.ndim 2
a.shape (3, 5)
a.size 15
a.dtype int64
a.itemsize 8
a.data &lt;memory at 0x7f1a641e17e0&gt;
</code></pre><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="使用-array-函数"><a href="#使用-array-函数" class="headerlink" title="使用 array 函数"></a>使用 array 函数</h3><p>使用 array 函数从常规的Python列表和元组创造数组。所创建的数组类型由原序列中的元素类型推导而来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#from numpy  import * # 申明为*，不需要前缀</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],[<span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</span><br><span class="line">print(<span class="string">'a'</span>,a)</span><br><span class="line">print(<span class="string">'b'</span>,b)</span><br><span class="line"><span class="comment"># 一个常见的错误包括用多个数值参数调用array而不是提供一个由数值组成的列表作为一个参数。 c = array(1, 2, 3, 4) wrong</span></span><br><span class="line"><span class="comment"># 数组将序列包含序列转化成二维的数组，序列包含序列包含序列转化成三维数组等等。</span></span><br><span class="line">c = array([(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)])</span><br><span class="line">print(<span class="string">'c:'</span>,c)</span><br><span class="line"><span class="comment"># 数组类型可以在创建时显示指定</span></span><br><span class="line">d = array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=complex)</span><br><span class="line">print(<span class="string">'d'</span>, d)</span><br></pre></td></tr></table></figure>
<pre><code>a [[ 1  2  3  4]
 [ 5  6  7  8]
 [10  2  3  4]]
b [ 1.2  3.5  5.1]
c: [[1 2 3 4]
 [4 5 6 7]]
d [ 1.+0.j  2.+0.j  3.+0.j  4.+0.j]
</code></pre><h3 id="使用占位符创建"><a href="#使用占位符创建" class="headerlink" title="使用占位符创建"></a>使用占位符创建</h3><ol>
<li>通常，数组的元素开始都是未知的，但是它的大小已知。因此，NumPy提供了一些使用占位符创建数组的函数。这最小化了扩展数组的需要和高昂的运算代价。</li>
<li>函数zero创建一个全是0的数组，函数ones创建一个全1的数组，函数empty创建一个内容随机并且依赖与内存状态的数组。默认创建的数组类型(dtype)都是float64。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.zeros((<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">print(np.ones((<span class="number">2</span>, <span class="number">4</span>)))</span><br><span class="line">print(np.empty((<span class="number">1</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]
[[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]]
[[  6.90466352e-310   6.90466352e-310]]
</code></pre><h3 id="使用arange-函数"><a href="#使用arange-函数" class="headerlink" title="使用arange 函数"></a>使用arange 函数</h3><p>为了创建一个数列，NumPy提供一个类似arange的函数返回数组而不是列表:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span>))</span><br><span class="line">print(np.arange(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0.3</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[10 15 20 25]
[ 0.   0.3  0.6  0.9  1.2  1.5  1.8  2.1  2.4  2.7]
</code></pre><h3 id="使用-lineapce-函数"><a href="#使用-lineapce-函数" class="headerlink" title="使用 lineapce 函数"></a>使用 lineapce 函数</h3><p>当<code>arange</code>使用浮点数参数时，由于有限的浮点数精度，通常无法预测获得的元素个数。因此，最好使用函数<code>linspace</code>去接收我们想要的元素个数来代替用<code>range</code>来指定步长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</span><br><span class="line">print(np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>)) <span class="comment"># 9 numbers 0 to 2</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">10</span>)</span><br><span class="line">f = np.sin(x)</span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure>
<pre><code>[ 0.    0.25  0.5   0.75  1.    1.25  1.5   1.75  2.  ]
[  0.00000000e+00   6.42787610e-01   9.84807753e-01   8.66025404e-01
   3.42020143e-01  -3.42020143e-01  -8.66025404e-01  -9.84807753e-01
  -6.42787610e-01  -2.44929360e-16]
</code></pre><p>其它函数array, zeros, zeros_like, ones, ones_like, empty, empty_like, arange, linspace, rand, randn, fromfunction, fromfile, 赋值拷贝。</p>
<h2 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h2><p>当你打印一个数组，NumPy以类似嵌套列表的形式显示它，但是呈以下布局：</p>
<ul>
<li>最后的轴从左到右打印</li>
<li>次后的轴从顶向下打印</li>
<li>剩下的轴从顶向下打印，每个切片通过一个空行与下一个隔开</li>
</ul>
<p>一维数组被打印成行，二维数组成矩阵，三维数组成矩阵列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">6</span>)<span class="comment"># 1d array</span></span><br><span class="line">print(a)</span><br><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)<span class="comment"># 2d array</span></span><br><span class="line">print(b)</span><br><span class="line">c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)<span class="comment"># 3d array</span></span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># 如果一个数组用来打印太大了，NumPy自动省略中间部分而只打印角落</span></span><br><span class="line">print(np.arange(<span class="number">10000</span>))</span><br><span class="line"><span class="comment"># 禁用NumPy的这种行为并强制打印整个数组，你可以设置printoptions参数来更改打印选项。</span></span><br><span class="line">print(np.set_printoptions(threshold=np.nan))</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
[   0    1    2 ..., 9997 9998 9999]
</code></pre><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>数组的算术运算是按元素的。新的数组被创建并且被结果填充。NumPy中的乘法运算符 * 指示按元素计算，矩阵乘法可以使用 dot 函数或创建矩阵对象实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">print(<span class="string">'b'</span>,b)</span><br><span class="line">c = a-b</span><br><span class="line">print(<span class="string">'c'</span>,c)</span><br><span class="line">print(<span class="string">'b**2'</span>,b**<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'10*np.sin(a)'</span>,<span class="number">10</span>*np.sin(a))</span><br><span class="line">print(<span class="string">'a&lt;35'</span>,a&lt;<span class="number">35</span>)</span><br></pre></td></tr></table></figure>
<pre><code>b [0 1 2 3]
c [1 1 1 1]
b**2 [0 1 4 9]
10*np.sin(a) [ 8.41470985  9.09297427  1.41120008 -7.56802495]
a&lt;35 [ True  True  True  True]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># NumPy中的乘法运算符*指示按元素计算，矩阵乘法可以使用dot函数或创建矩阵对象实现</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">print(numpy.arange(<span class="number">6</span>))</span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">1</span>,],</span><br><span class="line">           [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">print(<span class="string">'A*B'</span>,A*B)</span><br><span class="line">print(<span class="string">'A.dot(B)'</span>,A.dot(B))</span><br><span class="line">print(<span class="string">'np.dot(A, B)'</span>,np.dot(A, B))</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4 5]
A*B [[2 0]
 [0 4]]
A.dot(B) [[5 4]
 [3 4]]
np.dot(A, B) [[5 4]
 [3 4]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有些操作符像+=和*=被用来更改已存在数组而不创建一个新的数组。</span></span><br><span class="line">a = np.ones((<span class="number">2</span>, <span class="number">3</span>), dtype=int)</span><br><span class="line">b = np.random.random((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">a *= <span class="number">3</span></span><br><span class="line">print(a)</span><br><span class="line">b += a</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># print(a += b)</span></span><br></pre></td></tr></table></figure>
<pre><code>[[3 3 3]
 [3 3 3]]
[[ 3.77601215  3.67874255  3.09996677]
 [ 3.33283587  3.62279173  3.90198359]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当运算的是不同类型的数组时，结果数组靠近更普遍和精确的已知数组(这种行为叫做upcast)。</span></span><br><span class="line">a=np.ones(<span class="number">3</span>, dtype=np.int32)</span><br><span class="line">print(a)</span><br><span class="line">b = np.linspace(<span class="number">0</span>,pi,<span class="number">3</span>)</span><br><span class="line">print(b.dtype.name)</span><br><span class="line">c = a+b</span><br><span class="line">print(<span class="string">'c'</span>,c)</span><br><span class="line">print(<span class="string">'c dtype name'</span>,c.dtype.name)</span><br><span class="line">d = np.exp(c*<span class="number">1j</span>)</span><br><span class="line">print(d)</span><br><span class="line">print(<span class="string">'d dtype name'</span>, d.dtype.name) <span class="comment"># 许多非数组运算，如计算数组所有元素之和，被作为ndarray类的方法实现</span></span><br><span class="line">e = np.random.random((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(<span class="string">'e:'</span>,e)</span><br><span class="line">print(<span class="string">'e.sum:%s e.max:%s e.min:%s'</span>%(e.sum(),e.max(),e.min()))</span><br></pre></td></tr></table></figure>
<pre><code>[1 1 1]
float64
c [ 1.          2.57079633  4.14159265]
c dtype name float64
[ 0.54030231+0.84147098j -0.84147098+0.54030231j -0.54030231-0.84147098j]
d dtype name complex128
e: [[ 0.48800489  0.55796234  0.16459517]
 [ 0.40017365  0.41096132  0.01136693]]
e.sum:2.03306428928 e.max:0.557962337045 e.min:0.0113669291358
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些运算默认应用到数组好像它就是一个数字组成的列表，无关数组的形状。然而，指定axis参数你可以吧运算应用到数组指定的轴上：</span></span><br><span class="line">b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(<span class="string">'b'</span>,b)</span><br><span class="line">print(<span class="string">'b.sum(axis=0):'</span>,b.sum(axis=<span class="number">0</span>)) <span class="comment"># sum of each column</span></span><br><span class="line">print(<span class="string">'b.sum(axis=1):'</span>,b.sum(axis=<span class="number">1</span>))<span class="comment"># sum of each row</span></span><br><span class="line">print(<span class="string">'b.min(axis=0):'</span>,b.min(axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">'b.min(axis=1):'</span>,b.min(axis=<span class="number">1</span>))</span><br><span class="line">print(<span class="string">'b.max(axis=0):'</span>,b.max(axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">'b.max(axis=1):'</span>,b.max(axis=<span class="number">1</span>))</span><br><span class="line">print(<span class="string">'b.cumsum(axis=0):'</span>,b.cumsum(axis=<span class="number">0</span>))</span><br><span class="line">print(<span class="string">'b.cumsum(axis=1):'</span>,b.cumsum(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>b [[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
b.sum(axis=0): [12 15 18 21]
b.sum(axis=1): [ 6 22 38]
b.min(axis=0): [0 1 2 3]
b.min(axis=1): [0 4 8]
b.max(axis=0): [ 8  9 10 11]
b.max(axis=1): [ 3  7 11]
b.cumsum(axis=0): [[ 0  1  2  3]
 [ 4  6  8 10]
 [12 15 18 21]]
b.cumsum(axis=1): [[ 0  1  3  6]
 [ 4  9 15 22]
 [ 8 17 27 38]]
</code></pre><h2 id="通用函数-ufunc"><a href="#通用函数-ufunc" class="headerlink" title="通用函数(ufunc)"></a>通用函数(ufunc)</h2><p>NumPy提供常见的数学函数如sin,cos和exp。在NumPy中，这些叫作“通用函数”(ufunc)。在NumPy里这些函数作用<strong>按数组的元素</strong>运算，产生一个数组作为输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(<span class="number">3</span>)</span><br><span class="line">print(B)</span><br><span class="line">print(np.exp(B))</span><br><span class="line">print(np.sqrt(B))</span><br><span class="line">C = np.array([<span class="number">2.</span>, <span class="number">-1.</span>, <span class="number">4.</span>])</span><br><span class="line">d = np.add(B, C)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2]
[ 1.          2.71828183  7.3890561 ]
[ 0.          1.          1.41421356]
[ 2.  0.  6.]
</code></pre><p>更多函数<code>all, alltrue, any, apply along axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, conjugate, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sometrue, sort, std, sum, trace, transpose, var, vdot, vectorize, where</code> </p>
<h2 id="索引，切片和迭代-Indexing-Slicing-and-Iterating"><a href="#索引，切片和迭代-Indexing-Slicing-and-Iterating" class="headerlink" title="索引，切片和迭代(Indexing, Slicing and Iterating)"></a>索引，切片和迭代(Indexing, Slicing and Iterating)</h2><p>一维 数组可以被索引、切片和迭代，就像 列表 和其它Python序列。<br>一维数组的索引：与Python的列表索引功能相似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>)**<span class="number">2</span></span><br><span class="line">print(a)</span><br><span class="line">print(a[<span class="number">2</span>])</span><br><span class="line">print(a[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line">a[:<span class="number">6</span>:<span class="number">2</span>]=<span class="number">-1000</span> <span class="comment"># equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000</span></span><br><span class="line">print(a)</span><br><span class="line">print(a[::<span class="number">-1</span>])<span class="comment">#reverse a</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i**(<span class="number">1</span>/<span class="number">3.</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  4  9 16 25 36 49 64 81]
4
[ 4  9 16]
[-1000     1 -1000     9 -1000    25    36    49    64    81]
[   81    64    49    36    25 -1000     9 -1000     1 -1000]
nan
1.0
nan
2.08008382305
nan
2.92401773821
3.30192724889
3.65930571002
4.0
4.32674871092


/opt/conda/lib/python3.6/site-packages/ipykernel_launcher.py:9: RuntimeWarning: invalid value encountered in power
  if __name__ == &apos;__main__&apos;:
</code></pre><p>多维 数组可以每个轴有一个索引。这些索引由一个逗号分割的元组给出。(二维数组: 纵轴,横轴)<br>多维数组的索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[r1:r2, c1:c2]</span><br><span class="line">arr[1,1] 等价 arr[1][1]</span><br><span class="line">[:] 代表某个维度的数据</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>*x+y</span><br><span class="line">b = fromfunction(f, (<span class="number">5</span>, <span class="number">4</span>), dtype=int32)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">'b[2,3]:'</span>,b[<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(<span class="string">'b[0:5, 1]:'</span>,b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>])<span class="comment"># each row in the second column of b</span></span><br><span class="line">print(<span class="string">'b[:, 1]:'</span>,b[:, <span class="number">1</span>])<span class="comment"># equivalent to the previous example</span></span><br><span class="line">print(<span class="string">'b[1:3, : ]:'</span>,b[<span class="number">1</span>:<span class="number">3</span>, :])<span class="comment"># each column in the second and third row of b</span></span><br><span class="line">print(<span class="string">'b[-1]:'</span>,b[<span class="number">-1</span>])<span class="comment"># 当少于轴数的索引被提供时，确失的索引被认为是整个切片：b[-1,:]</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [10 11 12 13]
 [20 21 22 23]
 [30 31 32 33]
 [40 41 42 43]]
b[2,3]: 23
b[0:5, 1]: [ 1 11 21 31 41]
b[:, 1]: [ 1 11 21 31 41]
b[1:3, : ]: [[10 11 12 13]
 [20 21 22 23]]
b[-1]: [40 41 42 43]
</code></pre><ol>
<li><code>b[i]</code>中括号中的表达式被当作i和一系列:，来代表剩下的轴。NumPy也允许你使用“点”像<code>b[i,...]</code>。</li>
<li>dot(…)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴)，那么:<ol>
<li><code>x[1,2,…]</code> 等同于 <code>x[1,2,:,:,:]</code>,</li>
<li><code>x[…,3]</code> 等同于 <code>x[:,:,:,:,3]</code></li>
<li><code>x[4,…,5,:]</code> 等同 <code>x[4,:,:,5,:]</code>.</li>
</ol>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">               [<span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line">              [[<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</span><br><span class="line">               [<span class="number">110</span>, <span class="number">111</span>, <span class="number">112</span>]]])<span class="comment"># a 3d array (two stacked 2D array)</span></span><br><span class="line">print(c.shape)</span><br><span class="line">print(c[<span class="number">1</span>,...])<span class="comment"># same as c[1,:,:] or c[1]</span></span><br><span class="line">print(c[...,<span class="number">2</span>])<span class="comment"># same as c[:,:,2]</span></span><br></pre></td></tr></table></figure>
<pre><code>(2, 2, 3)
[[100 101 102]
 [110 111 112]]
[[  2  13]
 [102 112]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代多维数组是就第一个轴而言的:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 然而，如果一个人想对每个数组中元素进行运算，我们可以使用flat属性，该属性是数组元素的一个迭代器:</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line">    print(element)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> c.flat:</span><br><span class="line">    print(element)</span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
[[ 0  1  2]
 [10 12 13]]
[[100 101 102]
 [110 111 112]]
0
1
2
3
10
11
12
13
20
21
22
23
30
31
32
33
40
41
42
43
0
1
2
10
12
13
100
101
102
110
111
112
</code></pre><p>更多操作 <code>Indexing, Indexing (reference), newaxis, ndenumerate, indices</code></p>
<h2 id="形状操作（shape-manipulation）"><a href="#形状操作（shape-manipulation）" class="headerlink" title="形状操作（shape manipulation）"></a>形状操作（shape manipulation）</h2><h3 id="改变数组的形状"><a href="#改变数组的形状" class="headerlink" title="改变数组的形状"></a>改变数组的形状</h3><p>一个数组的形状由它每个轴上的元素个数给出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line"><span class="comment"># 一个数组的形状可以被多种命令修改, 下面三个命令返回的修改后的array,并不是修改原来的array</span></span><br><span class="line">print(<span class="string">'a.ravel():'</span>,a.ravel()) <span class="comment"># return the flatten array</span></span><br><span class="line">print(<span class="string">'orginal a:'</span>,a)</span><br><span class="line">print(<span class="string">'a.reshape(6, 2):'</span>,a.reshape(<span class="number">6</span>, <span class="number">2</span>))<span class="comment"># returns the array with a modified shape</span></span><br><span class="line">print(<span class="string">'orginal a:'</span>,a)</span><br><span class="line">print(<span class="string">'a.T:'</span>,a.T)<span class="comment"># return the array, transposed</span></span><br><span class="line">print(<span class="string">'orginal a:'</span>,a)</span><br><span class="line">print(<span class="string">'a.T.shape:'</span>,a.T.shape)</span><br><span class="line">print(<span class="string">'a.shape:'</span>,a.shape)</span><br><span class="line">print(<span class="string">'a.transpose():'</span>,a.transpose())</span><br></pre></td></tr></table></figure>
<pre><code>[[ 2.  6.  1.  9.]
 [ 3.  9.  1.  5.]
 [ 2.  4.  0.  2.]]
(3, 4)
a.ravel(): [ 2.  6.  1.  9.  3.  9.  1.  5.  2.  4.  0.  2.]
orginal a: [[ 2.  6.  1.  9.]
 [ 3.  9.  1.  5.]
 [ 2.  4.  0.  2.]]
a.reshape(6, 2): [[ 2.  6.]
 [ 1.  9.]
 [ 3.  9.]
 [ 1.  5.]
 [ 2.  4.]
 [ 0.  2.]]
orginal a: [[ 2.  6.  1.  9.]
 [ 3.  9.  1.  5.]
 [ 2.  4.  0.  2.]]
a.T: [[ 2.  3.  2.]
 [ 6.  9.  4.]
 [ 1.  1.  0.]
 [ 9.  5.  2.]]
orginal a: [[ 2.  6.  1.  9.]
 [ 3.  9.  1.  5.]
 [ 2.  4.  0.  2.]]
a.T.shape: (4, 3)
a.shape: (3, 4)
a.transpose(): [[ 2.  3.  2.]
 [ 6.  9.  4.]
 [ 1.  1.  0.]
 [ 9.  5.  2.]]
</code></pre><p>由<code>ravel()</code>展平的数组元素的顺序通常是<code>“C风格”</code>的，就是说，最右边的索引变化得最快，所以元素<code>a[0,0]</code>之后是<code>a[0,1]</code>。如果数组被改变形状<code>(reshape)</code>成其它形状，数组仍然是“C风格”的。NumPy通常创建一个以这个顺序保存数据的数组，所以<code>ravel()</code>将总是不需要复制它的参数。但是如果数组是通过切片其它数组或有不同寻常的选项时，它可能需要被复制。函数<code>reshape()</code>和<code>ravel()</code>还可以被同过一些可选参数构建成<code>FORTRAN</code>风格的数组，即最左边的索引变化最快。</p>
<p><code>reshape</code>函数改变参数形状并返回它，而<code>resize</code>函数改变数组自身,原本函数。<br>如果在改变形状操作中一个维度被给做-1，其维度将自动被计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'original a'</span>, a)</span><br><span class="line">b = a.reshape(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">'b:'</span>,b)</span><br><span class="line">print(<span class="string">'original a:'</span>,a)</span><br><span class="line">a.resize((<span class="number">6</span>,<span class="number">2</span>))</span><br><span class="line">print(a)</span><br><span class="line">print(a.reshape(<span class="number">4</span>, <span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>original a [[ 2.  6.]
 [ 1.  9.]
 [ 3.  9.]
 [ 1.  5.]
 [ 2.  4.]
 [ 0.  2.]]
b: [[ 2.  6.  1.  9.  3.  9.]
 [ 1.  5.  2.  4.  0.  2.]]
original a: [[ 2.  6.]
 [ 1.  9.]
 [ 3.  9.]
 [ 1.  5.]
 [ 2.  4.]
 [ 0.  2.]]
[[ 2.  6.]
 [ 1.  9.]
 [ 3.  9.]
 [ 1.  5.]
 [ 2.  4.]
 [ 0.  2.]]
[[ 2.  6.  1.]
 [ 9.  3.  9.]
 [ 1.  5.  2.]
 [ 4.  0.  2.]]
</code></pre><p>See also<br>ndarray.shape, reshape, resize, ravel</p>
<h3 id="组合-stack-不同的数组"><a href="#组合-stack-不同的数组" class="headerlink" title="组合(stack)不同的数组"></a>组合(stack)不同的数组</h3><p>几种方法可以沿不同轴将数组堆叠在一起</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">print(<span class="string">'original a:'</span>,a)</span><br><span class="line">b = np.floor(<span class="number">1</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">print(<span class="string">'original b:'</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack two arraies on vertical row_stack函数，另一方面，将一维数组以行组合成二维数组。</span></span><br><span class="line">print(np.vstack((a, b)))</span><br><span class="line"><span class="comment">#stack two arraies on horizon </span></span><br><span class="line"><span class="comment"># 对那些维度比二维更高的数组，hstack沿着第二个轴组合，vstack沿着第一个轴组合,concatenate允许可选参数给出组合时沿着的轴。</span></span><br><span class="line">print(np.hstack((a, b)))</span><br></pre></td></tr></table></figure>
<pre><code>original a: [[ 4.  3.]
 [ 4.  5.]]
original b: [[ 0.  0.]
 [ 0.  0.]]
[[ 4.  3.]
 [ 4.  5.]
 [ 0.  0.]
 [ 0.  0.]]
[[ 4.  3.  0.  0.]
 [ 4.  5.  0.  0.]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数column_stack以列将一维数组合成二维数组，它等同与vstack对一维数组。</span></span><br><span class="line"><span class="comment">#print(np.column_stack((a, b))) # with 2D arrays</span></span><br><span class="line">a = np.array([<span class="number">2.</span>, <span class="number">4.</span>])</span><br><span class="line">b = np.array([<span class="number">3.</span>, <span class="number">8.</span>])</span><br><span class="line">print(<span class="string">'np.column_stack((a, b)):'</span>,np.column_stack((a, b))) <span class="comment"># return with 2D arrays 二维数组 一列列合并 旧列作为新行</span></span><br><span class="line">print(<span class="string">'np.hstack((a, b)):'</span>,np.hstack((a, b))) <span class="comment"># return a different result 行合并</span></span><br><span class="line">print(<span class="string">'np.vstack((a, b)):'</span>,np.vstack((a, b)))<span class="comment"># return a different array 列合并 </span></span><br><span class="line">print(<span class="string">'a[:, newaxis]:'</span>,a[:,newaxis]) <span class="comment"># 允许生成2维数组</span></span><br><span class="line">print(<span class="string">'np.column_stack((a[:,newaxis],b[:,newaxis])):'</span>,np.column_stack((a[:,newaxis],b[:,newaxis])))</span><br><span class="line">print(np.hstack((a[:,newaxis], b[:,newaxis])))<span class="comment"># result is same</span></span><br></pre></td></tr></table></figure>
<pre><code>np.column_stack((a, b)): [[ 2.  3.]
 [ 4.  8.]]
np.hstack((a, b)): [ 2.  4.  3.  8.]
np.vstack((a, b)): [[ 2.  4.]
 [ 3.  8.]]
a[:, newaxis]: [[ 2.]
 [ 4.]]
np.column_stack((a[:,newaxis],b[:,newaxis])): [[ 2.  3.]
 [ 4.  8.]]
[[ 2.  3.]
 [ 4.  8.]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note</span></span><br><span class="line"><span class="comment"># 在复杂情况下，r_[]和c_[]对创建沿着一个方向组合的数很有用，它们允许范围符号(“:”):</span></span><br><span class="line"><span class="comment"># 当使用数组作为参数时，r_和c_的默认行为和vstack和hstack很像，但是允许可选的参数给出组合所沿着的轴的代号。</span></span><br><span class="line">print(np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[1 2 3 0 4]
</code></pre><h3 id="将一个数组分割-split-成几个小数组"><a href="#将一个数组分割-split-成几个小数组" class="headerlink" title="将一个数组分割(split)成几个小数组"></a>将一个数组分割(split)成几个小数组</h3><p>使用<code>hsplit</code>你能将数组沿着它的水平轴分割，或者指定返回相同形状数组的个数，或者指定在哪些列后发生分割:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>, <span class="number">12</span>)))</span><br><span class="line">print(a)</span><br><span class="line">print(np.hsplit(a, <span class="number">3</span>))  <span class="comment"># Split a into 3</span></span><br><span class="line">print(np.hsplit(a, (<span class="number">3</span>, <span class="number">4</span>)))<span class="comment"># Split a after the third and the fourth column</span></span><br><span class="line"><span class="comment"># vsplit沿着纵向的轴分割，array split允许指定沿哪个轴分割。</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 4.  9.  3.  1.  3.  6.  7.  6.  4.  3.  2.  8.]
 [ 4.  0.  2.  1.  0.  1.  1.  7.  8.  1.  8.  4.]]
[array([[ 4.,  9.,  3.,  1.],
       [ 4.,  0.,  2.,  1.]]), array([[ 3.,  6.,  7.,  6.],
       [ 0.,  1.,  1.,  7.]]), array([[ 4.,  3.,  2.,  8.],
       [ 8.,  1.,  8.,  4.]])]
[array([[ 4.,  9.,  3.],
       [ 4.,  0.,  2.]]), array([[ 1.],
       [ 1.]]), array([[ 3.,  6.,  7.,  6.,  4.,  3.,  2.,  8.],
       [ 0.,  1.,  1.,  7.,  8.,  1.,  8.,  4.]])]
</code></pre><h2 id="复制与视图（Copies-and-Views）"><a href="#复制与视图（Copies-and-Views）" class="headerlink" title="复制与视图（Copies and Views）"></a>复制与视图（Copies and Views）</h2><p>当运算和处理数组时，它们的数据有时被拷贝到新的数组有时不是。这通常是新手的困惑之源。这有三种情况:</p>
<h3 id="完全不拷贝"><a href="#完全不拷贝" class="headerlink" title="完全不拷贝"></a>完全不拷贝</h3><p>简单的赋值不拷贝数组对象或它们的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)</span><br><span class="line">b = a <span class="comment"># no new object is created</span></span><br><span class="line">print(b <span class="keyword">is</span> a) <span class="comment"># a and b are two names for the same ndarray object</span></span><br><span class="line">b.shape = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">print(a.shape)</span><br><span class="line"><span class="comment"># Python 传递不定对象作为参考，所以函数调用不拷贝数组。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(id(x))</span><br><span class="line">print(id(a)) <span class="comment"># id is a unique identifier of an object</span></span><br><span class="line">print(f(a))</span><br></pre></td></tr></table></figure>
<pre><code>True
(3, 4)
139751323982384
139751323982384
None
</code></pre><h3 id="视图-view-和浅复制"><a href="#视图-view-和浅复制" class="headerlink" title="视图(view)和浅复制"></a>视图(view)和浅复制</h3><p>不同的数组对象分享同一个数据。视图方法<code>view()</code><strong>创造一个新的数组对象</strong>指向同一数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">c = a.view()</span><br><span class="line">print(<span class="string">'c:'</span>,c)</span><br><span class="line">print(<span class="string">'c is a:'</span>,c <span class="keyword">is</span> a)</span><br><span class="line">print(<span class="string">'c.base is a:'</span>,c.base <span class="keyword">is</span> a) <span class="comment"># c is a view of the data owned by a</span></span><br><span class="line">print(<span class="string">'c.flags.owndata:'</span>,c.flags.owndata)</span><br><span class="line">print(<span class="string">'a.flags.owndata:'</span>,c.flags.owndata)</span><br><span class="line">c.shape=<span class="number">2</span>,<span class="number">6</span></span><br><span class="line">print(c.shape)</span><br><span class="line">print(a.shape)</span><br><span class="line">c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span></span><br><span class="line">print(<span class="string">'c:'</span>,c)</span><br><span class="line">print(<span class="string">'a:'</span>,a)</span><br></pre></td></tr></table></figure>
<pre><code>[[   0    1    2    3]
 [1234    5    6    7]
 [   8    9   10   11]]
c: [[   0    1    2    3]
 [1234    5    6    7]
 [   8    9   10   11]]
c is a: False
c.base is a: True
c.flags.owndata: False
a.flags.owndata: False
(2, 6)
(3, 4)
c: [[   0    1    2    3 1234    5]
 [   6    7    8    9   10   11]]
a: [[   0    1    2    3]
 [1234    5    6    7]
 [   8    9   10   11]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片数组返回它的一个视图：</span></span><br><span class="line">s = a[:, <span class="number">1</span>:<span class="number">3</span>]<span class="comment"># spaces add for clarity; could be also wirtten as "s=[:,1:3]"</span></span><br><span class="line">print(s)</span><br><span class="line">s[:]=<span class="number">10</span> <span class="comment"># s[:] is a view of s. Note the difference between s=10 and s[:]=10</span></span><br><span class="line">print(s)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[10 10]
 [10 10]
 [10 10]]
[[10 10]
 [10 10]
 [10 10]]
[[10 10 10  3]
 [10 10 10  7]
 [10 10 10 11]]
</code></pre><h3 id="深复制-deep-copy"><a href="#深复制-deep-copy" class="headerlink" title="深复制(deep copy)"></a>深复制(deep copy)</h3><p>这个复制方法完全复制<strong>数组和它的数据</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br><span class="line">d = a.copy() <span class="comment"># a new array object created</span></span><br><span class="line">print(d)</span><br><span class="line">print(d <span class="keyword">is</span> a)</span><br><span class="line">print(d.base <span class="keyword">is</span> a)</span><br><span class="line">d[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">print(d)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[10 10 10  3]
 [10 10 10  7]
 [10 10 10 11]]
[[10 10 10  3]
 [10 10 10  7]
 [10 10 10 11]]
False
False
[[999  10  10   3]
 [ 10  10  10   7]
 [ 10  10  10  11]]
[[10 10 10  3]
 [10 10 10  7]
 [10 10 10 11]]
</code></pre><h2 id="函数和方法-method-总览"><a href="#函数和方法-method-总览" class="headerlink" title="函数和方法(method)总览"></a>函数和方法(method)总览</h2><p>这是个NumPy函数和方法分类排列目录。这些名字链接到<a href="https://docs.scipy.org/doc/numpy/reference/routines.html#routines" target="_blank" rel="noopener">NumPy示例</a>,你可以看到这些函数起作用</p>
<ul>
<li>创建数组</li>
</ul>
<p><code>arange, array, copy, empty, empty_like, eye, fromfile, fromfunction, identity, linspace, logspace, mgrid, ogrid, ones, ones_like, r, zeros, zeros_like</code></p>
<ul>
<li>转化</li>
</ul>
<p><code>ndarray.astype, atleast_1d, atleast_2d, atleast_3d, mat</code></p>
<ul>
<li>操作</li>
</ul>
<p><code>array_split, column_stack, concatenate, diagonal, dsplit, dstack, hsplit, hstack, ndarray.item, newaxis, ravel, repeat, reshape, resize, squeeze, swapaxes, take, transpose, vsplit, vstack</code></p>
<ul>
<li>询问</li>
</ul>
<p><code>all, any, nonzero, where</code></p>
<ul>
<li>排序</li>
</ul>
<p><code>argmax, argmin, argsort, max, min, ptp, searchsorted, sort</code></p>
<ul>
<li>运算</li>
</ul>
<p><code>choose, compress, cumprod, cumsum, inner, fill, imag, prod, put, putmask, real, sum</code></p>
<ul>
<li>基本统计</li>
</ul>
<p><code>cov, mean, std, var</code></p>
<ul>
<li>基本线性代数</li>
</ul>
<p><code>cross, dot, outer, svd, vdot</code></p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="广播法则-rule"><a href="#广播法则-rule" class="headerlink" title="广播法则(rule)"></a>广播法则(rule)</h2><ul>
<li>广播法则能使通用函数有意义地处理不具有相同形状的输入。</li>
<li>广播第一法则是，如果所有的输入数组维度不都相同，一个<strong>“1”</strong>将被重复地添加在维度较小的数组上直至所有的数组拥有一样的维度。</li>
<li>广播第二法则确定长度为1的数组沿着特殊的方向表现地好像它有沿着那个方向最大形状的大小。对数组来说，沿着那个维度的数组元素的值理应相同。</li>
<li>应用广播法则之后，所有数组的大小必须匹配。<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">更多网址</a></li>
</ul>
<p>We will add the vector v to each row of the matrix x,<br>storing the result in the matrix y</p>
<p>对两个数组使用广播机制要遵守下列规则：</p>
<ol>
<li>如果数组的秩不同，使用1来将秩较小的数组进行扩展，直到两个数组的尺寸的长度都一样。</li>
<li>如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上长度为1，那么我们就说这两个数组在该维度上是相容的。</li>
<li>如果两个数组在所有维度上都是相容的，他们就能使用广播。</li>
<li>如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和那个较大的尺寸一样。</li>
<li>在任何一个维度上，如果一个数组的长度为1，另一个数组长度大于1，那么在该维度上，就好像是对第一个数组进行了复制</li>
</ol>
<h2 id="花哨的索引和索引技巧"><a href="#花哨的索引和索引技巧" class="headerlink" title="花哨的索引和索引技巧"></a>花哨的索引和索引技巧</h2><p>NumPy比普通Python序列提供更多的索引功能。除了索引整数和切片，正如我们之前看到的，数组可以被整数数组和布尔数组索引。</p>
<h3 id="通过数组索引"><a href="#通过数组索引" class="headerlink" title="通过数组索引"></a>通过数组索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>)**<span class="number">2</span></span><br><span class="line">print(<span class="string">'a:'</span>,a)</span><br><span class="line">i = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(a[i]) <span class="comment"># the elements of a at the positions i</span></span><br><span class="line">j = np.array([[<span class="number">3</span>, <span class="number">5</span>],[<span class="number">7</span>, <span class="number">9</span>]]) <span class="comment"># a bidimensional array of indices</span></span><br><span class="line">print(a[j]) <span class="comment"># the same shape as j</span></span><br></pre></td></tr></table></figure>
<pre><code>a: [  0   1   4   9  16  25  36  49  64  81 100 121]
[ 1  1  9 49 64]
[[ 9 25]
 [49 81]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当被索引数组a是多维的时，每一个唯一的索引数列指向a的第一维。以下示例通过将图片标签用调色版转换成色彩图像展示了这种行为。</span></span><br><span class="line">palette = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], <span class="comment">#black</span></span><br><span class="line">                   [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],<span class="comment">#red</span></span><br><span class="line">                   [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>],<span class="comment">#green</span></span><br><span class="line">                   [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>], <span class="comment"># blue</span></span><br><span class="line">                   [<span class="number">255</span>,<span class="number">255</span>, <span class="number">2555</span>]<span class="comment">#white</span></span><br><span class="line">                  ])</span><br><span class="line">image = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>]]) <span class="comment"># each value corresponds to a color in the palette</span></span><br><span class="line">print(palette[image])  <span class="comment"># the color(2, 4, 3) color image</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[[   0,    0,    0],
        [ 255,    0,    0],
        [   0,  255,    0],
        [   0,    0,    0]],

       [[   0,    0,    0],
        [   0,    0,  255],
        [ 255,  255, 2555],
        [   0,    0,    0]]])
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们也可以给出不不止一维的索引，每一维的索引数组必须有相同的形状。</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">i = np.array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">j = np.array([[<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">print(<span class="string">'a[i,j]:'</span>,a[i,j])</span><br><span class="line">print(<span class="string">'a[i,2]:'</span>,a[i,<span class="number">2</span>])</span><br><span class="line">print(<span class="string">'a[:,j]:'</span>,a[:,j])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
a[i,j]: [[ 2  5]
 [ 7 11]]
a[i,2]: [[ 2  6]
 [ 6 10]]
a[:,j]: [[[ 2  1]
  [ 3  3]]

 [[ 6  5]
  [ 7  7]]

 [[10  9]
  [11 11]]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自然，我们可以把i和j放到序列中(比如说列表)然后通过list索引。</span></span><br><span class="line">l = [i,j]</span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># 然而，我们不能把i和j放在一个数组中，因为这个数组将被解释成索引a的第一维。</span></span><br><span class="line">s = array( [i,j] ) <span class="comment"># not we want</span></span><br><span class="line">a[s]</span><br></pre></td></tr></table></figure>
<pre><code>[array([[0, 1],
       [1, 2]]), array([[2, 1],
       [3, 3]])]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另一个常用的数组索引用法是搜索时间序列最大值</span></span><br><span class="line">time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)                 <span class="comment"># time scale</span></span><br><span class="line">data = np.sin(arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)         <span class="comment"># 4 time-dependent series</span></span><br><span class="line">print(time)</span><br><span class="line">print(data)</span><br><span class="line">ind = data.argmax(axis=<span class="number">0</span>)                  <span class="comment"># index of the maxima for each series</span></span><br><span class="line">print(ind)</span><br><span class="line">time_max = time[ind]                       <span class="comment"># times corresponding to the maxima</span></span><br><span class="line">print(time_max)</span><br><span class="line">data_max = data[ind, range(data.shape[<span class="number">1</span>])] <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></span><br><span class="line">print(data_max)</span><br><span class="line">print(np.all(data_max == data.max(axis=<span class="number">0</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>[  20.     51.25   82.5   113.75  145.  ]
[[ 0.          0.84147098  0.90929743  0.14112001]
 [-0.7568025  -0.95892427 -0.2794155   0.6569866 ]
 [ 0.98935825  0.41211849 -0.54402111 -0.99999021]
 [-0.53657292  0.42016704  0.99060736  0.65028784]
 [-0.28790332 -0.96139749 -0.75098725  0.14987721]]
[2 0 3 1]
[  82.5    20.    113.75   51.25]
[ 0.98935825  0.84147098  0.99060736  0.6569866 ]
True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你也可以使用数组索引作为目标来赋值：</span></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 然而，当一个索引列表包含重复时，赋值被多次完成，保留最后的值：</span></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 这足够合理，但是小心如果你想用Python的+=结构，可能结果并非你所期望：</span></span><br><span class="line">a = np.arange(<span class="number">5</span>)</span><br><span class="line">a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]+=<span class="number">1</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 即使0在索引列表中出现两次，索引为0的元素仅仅增加一次。这是因为Python要求a+=1和a=a+1等同。</span></span><br></pre></td></tr></table></figure>
<pre><code>[0 1 2 3 4]
[0 0 2 0 0]
[2 1 3 3 4]
[1 1 3 3 4]
</code></pre><h3 id="通过布尔数组索引"><a href="#通过布尔数组索引" class="headerlink" title="通过布尔数组索引"></a>通过布尔数组索引</h3><p>当我们使用整数数组索引数组时，我们提供一个索引列表去选择。通过布尔数组索引的方法是不同的我们显式地选择数组中我们想要和不想要的元素。</p>
<p>我们能想到的使用布尔数组的索引最自然方式就是使用和原数组一样形状的布尔数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b = a &gt; <span class="number">4</span></span><br><span class="line">print(b) <span class="comment"># b is a boolean with a's shape</span></span><br><span class="line">print(a[b]) <span class="comment"># 1d array with the selected elements</span></span><br><span class="line"><span class="comment"># 这个属性在赋值时非常有用：</span></span><br><span class="line">a[b] = <span class="number">0</span>                                   <span class="comment"># All elements of 'a' higher than 4 become 0</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>[[False False False False]
 [False  True  True  True]
 [ True  True  True  True]]
[ 5  6  7  8  9 10 11]
[[0 1 2 3]
 [4 0 0 0]
 [0 0 0 0]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mandelbrot</span><span class="params">(h,w, maxit=<span class="number">20</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Returns an image of the Mandelbrot fractal of size (h,w)."""</span></span><br><span class="line">    y,x = np.ogrid[ <span class="number">-1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, <span class="number">-2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span> ]</span><br><span class="line">    c = x+y*<span class="number">1j</span></span><br><span class="line">    z = c</span><br><span class="line">    divtime = maxit + np.zeros(z.shape, dtype=int)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(maxit):</span><br><span class="line">        z = z**<span class="number">2</span> + c</span><br><span class="line">        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>            <span class="comment"># who is diverging</span></span><br><span class="line">        div_now = diverge &amp; (divtime==maxit)  <span class="comment"># who is diverging now</span></span><br><span class="line">        divtime[div_now] = i                  <span class="comment"># note when</span></span><br><span class="line">        z[diverge] = <span class="number">2</span>                        <span class="comment"># avoid diverging too much</span></span><br><span class="line">        <span class="keyword">return</span> divtime</span><br><span class="line">plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/28/Numpy使用/output_58_0.png" alt="png"></p>
<p>第二种通过布尔来索引的方法更近似于整数索引；对数组的每个维度我们给一个一维布尔数组来选择我们想要的切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">b1 = np.array([<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">True</span>]) <span class="comment"># first dim selection</span></span><br><span class="line">b2 = np.array([<span class="keyword">True</span>,<span class="keyword">False</span>,<span class="keyword">True</span>,<span class="keyword">False</span>])       <span class="comment"># second dim selection</span></span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">'a[b1,:]:'</span>,a[b1,:])</span><br><span class="line">print(<span class="string">'a[b1]:'</span>,a[b1])</span><br><span class="line">print(<span class="string">'a[:,b2]:'</span>,a[:,b2]) <span class="comment"># selecting columns</span></span><br><span class="line">print(<span class="string">'a[b1,b2]:'</span>,a[b1,b2])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
a[b1,:]: [[ 4  5  6  7]
 [ 8  9 10 11]]
a[b1]: [[ 4  5  6  7]
 [ 8  9 10 11]]
a[:,b2]: [[ 0  2]
 [ 4  6]
 [ 8 10]]
a[b1,b2]: [ 4 10]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># Add v to each row of x using broadcasting</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 2  2  4]
 [ 5  5  7]
 [ 8  8 10]
 [11 11 13]]
</code></pre><h2 id="ix-函数"><a href="#ix-函数" class="headerlink" title="ix_()函数"></a><code>ix_()</code>函数</h2><p><code>ix_</code>函数可以为了获得多元组的结果而用来结合不同向量。例如，如果你想要用所有向量a、b和c元素组成的三元组来计算<code>a+b*c</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line">c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line">ax,bx,cx = np.ix_(a,b,c)</span><br><span class="line">print(<span class="string">'ax:'</span>,ax)</span><br><span class="line">print(<span class="string">'bx:'</span>,bx)</span><br><span class="line">print(<span class="string">'cx:'</span>,cx)</span><br><span class="line">print(ax.shape, bx.shape, cx.shape)</span><br><span class="line">result = ax+bx*cx</span><br><span class="line">print(<span class="string">'result:'</span>,result)</span><br><span class="line">print(result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line">print(a[<span class="number">3</span>]+b[<span class="number">2</span>]*c[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<pre><code>ax: [[[2]]

 [[3]]

 [[4]]

 [[5]]]
bx: [[[8]
  [5]
  [4]]]
cx: [[[5 4 6 8 3]]]
(4, 1, 1) (1, 3, 1) (1, 1, 5)
result: [[[42 34 50 66 26]
  [27 22 32 42 17]
  [22 18 26 34 14]]

 [[43 35 51 67 27]
  [28 23 33 43 18]
  [23 19 27 35 15]]

 [[44 36 52 68 28]
  [29 24 34 44 19]
  [24 20 28 36 16]]

 [[45 37 53 69 29]
  [30 25 35 45 20]
  [25 21 29 37 17]]]
17
17
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你也可以实行如下简化：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ufunc_reduce</span><span class="params">(ufct, *vectors)</span>:</span></span><br><span class="line">    vs = ix_(*vectors)</span><br><span class="line">    r = ufct.identity</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> vs:</span><br><span class="line">        r = ufct(r,v)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"><span class="comment"># 然后这样使用它：</span></span><br><span class="line">ufunc_reduce(add,a,b,c)</span><br><span class="line"><span class="comment"># 这个reduce与ufunc.reduce(比如说add.reduce)相比的优势在于它利用了广播法则，避免了创建一个输出大小乘以向量个数的参数数组。</span></span><br></pre></td></tr></table></figure>
<pre><code>array([[[15, 14, 16, 18, 13],
        [12, 11, 13, 15, 10],
        [11, 10, 12, 14,  9]],

       [[16, 15, 17, 19, 14],
        [13, 12, 14, 16, 11],
        [12, 11, 13, 15, 10]],

       [[17, 16, 18, 20, 15],
        [14, 13, 15, 17, 12],
        [13, 12, 14, 16, 11]],

       [[18, 17, 19, 21, 16],
        [15, 14, 16, 18, 13],
        [14, 13, 15, 17, 12]]])
</code></pre><h3 id="用字符串索引"><a href="#用字符串索引" class="headerlink" title="用字符串索引"></a>用字符串索引</h3><p>See Structured arrays.</p>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="简单数组运算"><a href="#简单数组运算" class="headerlink" title="简单数组运算"></a>简单数组运算</h2><p>参考numpy文件夹中的linalg.py获得更多信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(a.T)</span><br><span class="line">print(np.linalg.inv(a))</span><br><span class="line">u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; "eye" represents "I"</span></span><br><span class="line">print(u)</span><br><span class="line">j = np.array([[<span class="number">0.0</span>, <span class="number">-1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line">print(np.dot (j, j)) <span class="comment"># matrix product</span></span><br><span class="line">print(np.trace(u))</span><br><span class="line">y = np.array([[<span class="number">5.</span>], [<span class="number">7.</span>]])</span><br><span class="line">print(np.linalg.solve(a, y))</span><br><span class="line">print(np.linalg.eig(j))</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1.  2.]
 [ 3.  4.]]
[[ 1.  3.]
 [ 2.  4.]]
[[-2.   1. ]
 [ 1.5 -0.5]]
[[ 1.  0.]
 [ 0.  1.]]
[[-1.  0.]
 [ 0. -1.]]
2.0
</code></pre><h2 id="矩阵类"><a href="#矩阵类" class="headerlink" title="矩阵类"></a>矩阵类</h2><p>这是一个关于矩阵类的简短介绍。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = np.matrix(<span class="string">'1.0 2.0;3.0 4.0'</span>)</span><br><span class="line">print(A)</span><br><span class="line">print(type(A))</span><br><span class="line">print(A.T) <span class="comment"># transpose</span></span><br><span class="line">X = np.matrix(<span class="string">'5.0 7.0'</span>)</span><br><span class="line">Y = X.T</span><br><span class="line">print(Y)</span><br><span class="line">print(A*Y) <span class="comment"># matrix multiplication</span></span><br><span class="line">print(A.I) <span class="comment"># inverse</span></span><br></pre></td></tr></table></figure>
<pre><code>[[ 1.  2.]
 [ 3.  4.]]
&lt;class &apos;numpy.matrixlib.defmatrix.matrix&apos;&gt;
[[ 1.  3.]
 [ 2.  4.]]
[[ 5.]
 [ 7.]]
[[ 19.]
 [ 43.]]
[[-2.   1. ]
 [ 1.5 -0.5]]
</code></pre><h3 id="索引：比较矩阵和二维数组"><a href="#索引：比较矩阵和二维数组" class="headerlink" title="索引：比较矩阵和二维数组"></a>索引：比较矩阵和二维数组</h3><p>注意NumPy中数组和矩阵有些重要的区别。NumPy提供了两个基本的对象：一个N维数组对象和一个通用函数对象。其它对象都是建构在它们之上的。特别的，矩阵是继承自NumPy数组对象的二维数组对象。对数组和矩阵，索引都必须包含合适的一个或多个这些组合：整数标量、省略号(ellipses)、整数列表;布尔值，整数或布尔值构成的元组，和一个一维整数或布尔值数组。矩阵可以被用作矩阵的索引，但是通常需要数组、列表或者其它形式来完成这个任务。</p>
<p>像平常在Python中一样，索引是从0开始的。传统上我们用矩形的行和列表示一个二维数组或矩阵，其中沿着0轴的方向被穿过的称作行，沿着1轴的方向被穿过的是列。</p>
<p>让我们创建数组和矩阵用来切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A=np.arange(<span class="number">12</span>)</span><br><span class="line">print(A)</span><br><span class="line">A.shape=(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(A)</span><br><span class="line">M = np.mat(A.copy())</span><br><span class="line">print(M)</span><br><span class="line">print(type(A), type(M))</span><br></pre></td></tr></table></figure>
<pre><code>[ 0  1  2  3  4  5  6  7  8  9 10 11]
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&lt;class &apos;numpy.ndarray&apos;&gt; &lt;class &apos;numpy.matrixlib.defmatrix.matrix&apos;&gt;
</code></pre><p>现在，让我们简单的切几片。基本的切片使用切片对象或整数。例如，<code>A[:]</code>和<code>M[:]</code>的求值将表现得和Python索引很相似。然而要注意很重要的一点就是NumPy切片数组不创建数据的副本;切片提供统一数据的视图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(A[:],A[:].shape)</span><br><span class="line">print(M[:],M[:].shape)</span><br><span class="line"><span class="comment"># 现在有些和Python索引不同的了：你可以同时使用 逗号 分割索引来沿着多个轴索引。</span></span><br><span class="line">print(A[:,<span class="number">1</span>]); print(A[:,<span class="number">1</span>].shape)</span><br><span class="line">print(M[:,<span class="number">1</span>]); print(M[:,<span class="number">1</span>].shape)</span><br></pre></td></tr></table></figure>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]] (3, 4)
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]] (3, 4)
[1 5 9]
(3,)
[[1]
 [5]
 [9]]
(3, 1)
</code></pre><p> 注意最后两个结果的不同。<strong>对二维数组使用一个冒号产生一个一维数组，然而矩阵产生了一个二维矩阵</strong>。例如，一个<code>M[2,:]</code>切片产生了一个形状为(1,4)的矩阵，相比之下，一个数组的切片总是产生一个最低可能维度11的数组。例如，如果C是一个三维数组，<code>C[...,1]</code>产生一个二维的数组而<code>C[1,:,1]</code>产生一个一维数组。从这时开始，如果相应的矩阵切片结果是相同的话，我们将只展示数组切片的结果。</p>
<p> 假如我们想要一个数组的第一列和第三列，一种方法是使用列表切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(A[:,[<span class="number">1</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="comment">#稍微复杂点的方法是使用take()方法(method):</span></span><br><span class="line">print(A[:,].take([<span class="number">1</span>,<span class="number">3</span>],axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 如果我们想跳过第一行，我们可以这样：</span></span><br><span class="line">print(A[<span class="number">1</span>:,].take([<span class="number">1</span>,<span class="number">3</span>],axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 或者我们仅仅使用A[1:,[1,3]]。还有一种方法是通过矩阵向量积(叉积)。</span></span><br><span class="line">print(A[ix_((<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>))])</span><br><span class="line"><span class="comment"># 现在让我们做些更复杂的。比如说我们想要保留第一行大于1的列。一种方法是创建布尔索引：</span></span><br><span class="line">print(A[<span class="number">0</span>,:]&gt;<span class="number">1</span>)</span><br><span class="line">print(A[:,A[<span class="number">0</span>,:]&gt;<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<pre><code>[[ 1  3]
 [ 5  7]
 [ 9 11]]
[[ 1  3]
 [ 5  7]
 [ 9 11]]
[[ 5  7]
 [ 9 11]]
[[ 5  7]
 [ 9 11]]
[False False  True  True]
[[ 2  3]
 [ 6  7]
 [10 11]]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 就是我们想要的！但是索引矩阵没这么方便。</span></span><br><span class="line">M = np.mat(A.copy())</span><br><span class="line">print(M[<span class="number">0</span>,:]&gt;<span class="number">1</span>)</span><br><span class="line"><span class="comment"># print(M[:,M[0,:]&gt;1])</span></span><br><span class="line"><span class="comment"># 这个过程的问题是用“矩阵切片”来切片产生一个矩阵12，但是矩阵有个方便的A属性，它的值是数组呈现的。所以我们仅仅做以下替代：</span></span><br><span class="line">print(M[:,M.A[<span class="number">0</span>,<span class="number">1</span>]&gt;<span class="number">1</span>])</span><br><span class="line">print(M[:,M.A[<span class="number">0</span>,:]&gt;<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 如果我们想要在矩阵两个方向有条件地切片，我们必须稍微调整策略，代之以：</span></span><br><span class="line">print(A[A[:,<span class="number">0</span>]&gt;<span class="number">2</span>,A[<span class="number">0</span>,:]&gt;<span class="number">1</span>])</span><br><span class="line">print(M[M.A[:,<span class="number">0</span>]&gt;<span class="number">2</span>,M.A[<span class="number">0</span>,:]&gt;<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 我们需要使用向量积ix_:</span></span><br><span class="line">print(A[ix_(A[:,<span class="number">0</span>]&gt;<span class="number">2</span>,A[<span class="number">0</span>,:]&gt;<span class="number">1</span>)])</span><br><span class="line">print(M[ix_(M.A[:,<span class="number">0</span>]&gt;<span class="number">2</span>,M.A[<span class="number">0</span>,:]&gt;<span class="number">1</span>)])</span><br></pre></td></tr></table></figure>
<pre><code>[[False False  True  True]]
[]
[[ 2  3]
 [ 6  7]
 [10 11]]
[ 6 11]
[[ 6 11]]
[[ 6  7]
 [10 11]]
[[ 6  7]
 [10 11]]
</code></pre><h1 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="技巧和提示"></a>技巧和提示</h1><h2 id="“自动”改变形状"><a href="#“自动”改变形状" class="headerlink" title="“自动”改变形状"></a>“自动”改变形状</h2><p>更改数组的维度，你可以省略一个尺寸，它将被自动推导出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">30</span>)</span><br><span class="line">a.shape = <span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>  <span class="comment"># -1 means "whatever is needed"</span></span><br><span class="line">print(a.shape)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<pre><code>(2, 5, 3)
[[[ 0  1  2]
  [ 3  4  5]
  [ 6  7  8]
  [ 9 10 11]
  [12 13 14]]

 [[15 16 17]
  [18 19 20]
  [21 22 23]
  [24 25 26]
  [27 28 29]]]
</code></pre><h2 id="向量组合-stacking"><a href="#向量组合-stacking" class="headerlink" title="向量组合(stacking)"></a>向量组合(stacking)</h2><p>我们如何用两个相同尺寸的行向量列表构建一个二维数组？在MATLAB中这非常简单：如果x和y是两个相同长度的向量，你仅仅需要做<code>m=[x;y]</code>。在NumPy中这个过程通过函数<code>column_stack、dstack、hstack和vstack来</code>完成，取决于你想要在那个维度上组合。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">y = np.arange(<span class="number">5</span>)</span><br><span class="line">m = vstack([x,y])</span><br><span class="line">print(m)</span><br><span class="line">xy = hstack([x,y])</span><br><span class="line">print(xy)</span><br></pre></td></tr></table></figure>
<pre><code>[[0 2 4 6 8]
 [0 1 2 3 4]]
[0 2 4 6 8 0 1 2 3 4]
</code></pre><h2 id="直方图-histogram"><a href="#直方图-histogram" class="headerlink" title="直方图(histogram)"></a>直方图(histogram)</h2><p>NumPy中histogram函数应用到一个数组返回一对变量：直方图数组和箱式向量。注意：<code>matplotlib</code>也有一个用来建立直方图的函数(叫作hist,正如matlab中一样)与NumPy中的不同。主要的差别是pylab.hist自动绘制直方图，而<code>numpy.histogram</code>仅仅产生数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line"><span class="comment"># Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2</span></span><br><span class="line">mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></span><br><span class="line">v = numpy.random.normal(mu,sigma,<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># Plot a normalized histogram with 50 bins</span></span><br><span class="line">pylab.hist(v, bins=<span class="number">50</span>, normed=<span class="number">1</span>)       <span class="comment"># matplotlib version (plot)</span></span><br><span class="line">pylab.show()</span><br><span class="line"><span class="comment"># Compute the histogram with numpy and then plot it</span></span><br><span class="line">(n, bins) = numpy.histogram(v, bins=<span class="number">50</span>, normed=<span class="keyword">True</span>)  <span class="comment"># NumPy version (no plot)</span></span><br><span class="line">pylab.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:<span class="number">-1</span>]), n)</span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fallenk.github.io/2018/09/28/Numpy使用/" data-id="cjpy37ft8000h4j8oz61bvego" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码/">代码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程/">编程</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2018/09/29/Deep-Image-Prior/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Deep Image Prior
        
      </div>
    </a>
  
  
    <a href="/2018/09/28/Python入门/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Python入门</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Numpy教程"><span class="toc-number">1.</span> <span class="toc-text">Numpy教程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础篇"><span class="toc-number">2.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个例子："><span class="toc-number">2.1.</span> <span class="toc-text">一个例子：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建数组"><span class="toc-number">2.2.</span> <span class="toc-text">创建数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-array-函数"><span class="toc-number">2.2.1.</span> <span class="toc-text">使用 array 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用占位符创建"><span class="toc-number">2.2.2.</span> <span class="toc-text">使用占位符创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用arange-函数"><span class="toc-number">2.2.3.</span> <span class="toc-text">使用arange 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-lineapce-函数"><span class="toc-number">2.2.4.</span> <span class="toc-text">使用 lineapce 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打印数组"><span class="toc-number">2.3.</span> <span class="toc-text">打印数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本运算"><span class="toc-number">2.4.</span> <span class="toc-text">基本运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通用函数-ufunc"><span class="toc-number">2.5.</span> <span class="toc-text">通用函数(ufunc)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引，切片和迭代-Indexing-Slicing-and-Iterating"><span class="toc-number">2.6.</span> <span class="toc-text">索引，切片和迭代(Indexing, Slicing and Iterating)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形状操作（shape-manipulation）"><span class="toc-number">2.7.</span> <span class="toc-text">形状操作（shape manipulation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#改变数组的形状"><span class="toc-number">2.7.1.</span> <span class="toc-text">改变数组的形状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合-stack-不同的数组"><span class="toc-number">2.7.2.</span> <span class="toc-text">组合(stack)不同的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将一个数组分割-split-成几个小数组"><span class="toc-number">2.7.3.</span> <span class="toc-text">将一个数组分割(split)成几个小数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制与视图（Copies-and-Views）"><span class="toc-number">2.8.</span> <span class="toc-text">复制与视图（Copies and Views）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#完全不拷贝"><span class="toc-number">2.8.1.</span> <span class="toc-text">完全不拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图-view-和浅复制"><span class="toc-number">2.8.2.</span> <span class="toc-text">视图(view)和浅复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深复制-deep-copy"><span class="toc-number">2.8.3.</span> <span class="toc-text">深复制(deep copy)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数和方法-method-总览"><span class="toc-number">2.9.</span> <span class="toc-text">函数和方法(method)总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进阶"><span class="toc-number">3.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#广播法则-rule"><span class="toc-number">3.1.</span> <span class="toc-text">广播法则(rule)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#花哨的索引和索引技巧"><span class="toc-number">3.2.</span> <span class="toc-text">花哨的索引和索引技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过数组索引"><span class="toc-number">3.2.1.</span> <span class="toc-text">通过数组索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过布尔数组索引"><span class="toc-number">3.2.2.</span> <span class="toc-text">通过布尔数组索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ix-函数"><span class="toc-number">3.3.</span> <span class="toc-text">ix_()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用字符串索引"><span class="toc-number">3.3.1.</span> <span class="toc-text">用字符串索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线性代数"><span class="toc-number">4.</span> <span class="toc-text">线性代数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简单数组运算"><span class="toc-number">4.1.</span> <span class="toc-text">简单数组运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#矩阵类"><span class="toc-number">4.2.</span> <span class="toc-text">矩阵类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引：比较矩阵和二维数组"><span class="toc-number">4.2.1.</span> <span class="toc-text">索引：比较矩阵和二维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#技巧和提示"><span class="toc-number">5.</span> <span class="toc-text">技巧和提示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#“自动”改变形状"><span class="toc-number">5.1.</span> <span class="toc-text">“自动”改变形状</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#向量组合-stacking"><span class="toc-number">5.2.</span> <span class="toc-text">向量组合(stacking)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直方图-histogram"><span class="toc-number">5.3.</span> <span class="toc-text">直方图(histogram)</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2018 Fallenk Liu&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;fallenk_liu@yeah.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>